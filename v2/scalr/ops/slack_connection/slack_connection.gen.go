// Code generated by scalr-gen. DO NOT EDIT.

package slack_connection

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/scalr/go-scalr/v2/scalr/client"
	"github.com/scalr/go-scalr/v2/scalr/schemas"
)

// Client provides access to SlackConnection operations
type Client struct {
	httpClient *client.HTTPClient
}

// New creates a new SlackConnection client
func New(httpClient *client.HTTPClient) *Client {
	return &Client{httpClient: httpClient}
}

// Remove Slack App connection for the account.
func (c *Client) DeleteSlackConnectionRaw(ctx context.Context, account string) (*http.Response, error) {
	path := "/integrations/slack/{account}/connection"
	path = strings.ReplaceAll(path, "{account}", url.PathEscape(account))

	return c.httpClient.Delete(ctx, path, nil)
}

// Remove Slack App connection for the account.
func (c *Client) DeleteSlackConnection(ctx context.Context, account string) (*client.Response, error) {
	httpResp, err := c.DeleteSlackConnectionRaw(ctx, account)
	if err != nil {
		return nil, err
	}
	defer httpResp.Body.Close()

	resp := &client.Response{Response: httpResp}

	return resp, nil
}

// Get a specific Slack channel by ID.
func (c *Client) GetSlackChannelRaw(ctx context.Context, account string, channelId string) (*http.Response, error) {
	path := "/integrations/slack/{account}/connection/channels/{channel_id}"
	path = strings.ReplaceAll(path, "{account}", url.PathEscape(account))
	path = strings.ReplaceAll(path, "{channel_id}", url.PathEscape(channelId))

	return c.httpClient.Get(ctx, path, nil)
}

// Get a specific Slack channel by ID.
func (c *Client) GetSlackChannel(ctx context.Context, account string, channelId string) (string, *client.Response, error) {
	httpResp, err := c.GetSlackChannelRaw(ctx, account, channelId)
	if err != nil {
		return "", nil, err
	}
	defer httpResp.Body.Close()

	resp := &client.Response{Response: httpResp}

	bodyBytes, err := io.ReadAll(httpResp.Body)
	if err != nil {
		return "", resp, fmt.Errorf("failed to read response body: %w", err)
	}
	return string(bodyBytes), resp, nil
}

// Show details of account's Slack App connection.
func (c *Client) GetSlackConnectionRaw(ctx context.Context, account string) (*http.Response, error) {
	path := "/integrations/slack/{account}/connection"
	path = strings.ReplaceAll(path, "{account}", url.PathEscape(account))

	return c.httpClient.Get(ctx, path, nil)
}

// Show details of account's Slack App connection.
func (c *Client) GetSlackConnection(ctx context.Context, account string) (*schemas.SlackConnection, *client.Response, error) {
	httpResp, err := c.GetSlackConnectionRaw(ctx, account)
	if err != nil {
		return nil, nil, err
	}
	defer httpResp.Body.Close()

	resp := &client.Response{Response: httpResp}

	var result struct {
		Data     schemas.SlackConnection  `json:"data"`
		Included []map[string]interface{} `json:"included"`
	}
	if err := json.NewDecoder(httpResp.Body).Decode(&result); err != nil {
		return nil, resp, fmt.Errorf("failed to decode response: %w", err)
	}

	// Populate included resources into relationships
	if len(result.Included) > 0 {
		result.Data.Relationships.PopulateIncludes(result.Included)
	}
	return &result.Data, resp, nil
}

// Get a list of channels from associated Slack workspace.
func (c *Client) ListSlackChannelsRaw(ctx context.Context, account string, opts *ListSlackChannelsOptions) (*http.Response, error) {
	path := "/integrations/slack/{account}/connection/channels"
	path = strings.ReplaceAll(path, "{account}", url.PathEscape(account))

	params := url.Values{}
	if opts != nil {
		// Handle parameter: Query (string)
		if opts.Query != "" {
			params.Set("query", opts.Query)
		}
		// Handle parameter: IgnoreCache (string)
		if opts.IgnoreCache != "" {
			params.Set("ignore_cache", opts.IgnoreCache)
		}
		if opts.PageNumber > 0 {
			params.Set("page[number]", fmt.Sprintf("%d", opts.PageNumber))
		}
		if opts.PageSize > 0 {
			params.Set("page[size]", fmt.Sprintf("%d", opts.PageSize))
		}
		// Add filters
		for k, v := range opts.Filter {
			params.Set("filter["+k+"]", v)
		}
	}
	if len(params) > 0 {
		path += "?" + params.Encode()
	}

	return c.httpClient.Get(ctx, path, nil)
}

// Get a list of channels from associated Slack workspace.
func (c *Client) ListSlackChannels(ctx context.Context, account string, opts *ListSlackChannelsOptions) (string, *client.Response, error) {
	httpResp, err := c.ListSlackChannelsRaw(ctx, account, opts)
	if err != nil {
		return "", nil, err
	}
	defer httpResp.Body.Close()

	resp := &client.Response{Response: httpResp}

	bodyBytes, err := io.ReadAll(httpResp.Body)
	if err != nil {
		return "", resp, fmt.Errorf("failed to read response body: %w", err)
	}
	return string(bodyBytes), resp, nil
}

// ListSlackChannelsOptions holds optional parameters for ListSlackChannels
type ListSlackChannelsOptions struct {
	// The search string. Supports search by channel name.
	Query string
	// Invalidate cache for the request
	IgnoreCache string
	// Page number
	PageNumber int
	// Page size
	PageSize int
	Filter   map[string]string
}
