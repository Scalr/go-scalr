// Code generated by scalr-gen. DO NOT EDIT.

package run

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"iter"
	"net/http"
	"net/url"
	"strings"

	"github.com/scalr/go-scalr/v2/scalr/client"
	"github.com/scalr/go-scalr/v2/scalr/schemas"
)

// Client provides access to Run operations
type Client struct {
	httpClient *client.HTTPClient
}

// New creates a new Run client
func New(httpClient *client.HTTPClient) *Client {
	return &Client{httpClient: httpClient}
}

// Interrupt a run that is currently planning or applying. Performing a cancel is roughly equivalent to hitting `ctrl+c` during a Terraform plan or apply on the CLI. The running Terraform process is sent an `INT` signal, which instructs Terraform to end its work and wrap up in the safest way possible.
func (c *Client) CancelRunRaw(ctx context.Context, run string, req *schemas.Comment) (*http.Response, error) {
	path := "/runs/{run}/actions/cancel"
	path = strings.ReplaceAll(path, "{run}", url.PathEscape(run))

	// Plain JSON request (not JSON:API)
	headers := map[string]string{"Content-Type": "application/json"}
	return c.httpClient.Post(ctx, path, req, headers)
}

// Interrupt a run that is currently planning or applying. Performing a cancel is roughly equivalent to hitting `ctrl+c` during a Terraform plan or apply on the CLI. The running Terraform process is sent an `INT` signal, which instructs Terraform to end its work and wrap up in the safest way possible.
func (c *Client) CancelRun(ctx context.Context, run string, req *schemas.Comment) (*client.Response, error) {
	httpResp, err := c.CancelRunRaw(ctx, run, req)
	if err != nil {
		return nil, err
	}
	defer httpResp.Body.Close()

	resp := &client.Response{Response: httpResp}

	return resp, nil
}

// Apply a run that is paused waiting for confirmation after a plan. This includes runs in the `planned` and `policy_checked` states. This action is only required for runs that can't be auto-applied.
func (c *Client) ConfirmRunRaw(ctx context.Context, run string, req *schemas.ConfirmRequest) (*http.Response, error) {
	path := "/runs/{run}/actions/apply"
	path = strings.ReplaceAll(path, "{run}", url.PathEscape(run))

	// Plain JSON request (not JSON:API)
	headers := map[string]string{"Content-Type": "application/json"}
	return c.httpClient.Post(ctx, path, req, headers)
}

// Apply a run that is paused waiting for confirmation after a plan. This includes runs in the `planned` and `policy_checked` states. This action is only required for runs that can't be auto-applied.
func (c *Client) ConfirmRun(ctx context.Context, run string, req *schemas.ConfirmRequest) (*client.Response, error) {
	httpResp, err := c.ConfirmRunRaw(ctx, run, req)
	if err != nil {
		return nil, err
	}
	defer httpResp.Body.Close()

	resp := &client.Response{Response: httpResp}

	return resp, nil
}

// A run performs terraform plan and apply using a configuration version and the workspace's current variables. If the configuration version is omitted, the run will be created using the workspace's latest configuration version. If you want to create a dry run, specify `is-dry: true` or reference configuration version with `is-dry: true` in the relationships.
func (c *Client) CreateRunRaw(ctx context.Context, req *schemas.RunRequest, opts *CreateRunOptions) (*http.Response, error) {
	path := "/runs"

	params := url.Values{}
	if opts != nil {
		// Handle parameter: VcsUserId (int)
		// Complex type int - skip for now
		// Handle parameter: VcsTaskId (string)
		if opts.VcsTaskId != "" {
			params.Set("vcs-task-id", opts.VcsTaskId)
		}
		// Add filters
		for k, v := range opts.Filter {
			params.Set("filter["+k+"]", v)
		}
	}
	if len(params) > 0 {
		path += "?" + params.Encode()
	}

	// Wrap request in JSON:API envelope
	body := map[string]interface{}{"data": req}
	return c.httpClient.Post(ctx, path, body, nil)
}

// A run performs terraform plan and apply using a configuration version and the workspace's current variables. If the configuration version is omitted, the run will be created using the workspace's latest configuration version. If you want to create a dry run, specify `is-dry: true` or reference configuration version with `is-dry: true` in the relationships.
func (c *Client) CreateRun(ctx context.Context, req *schemas.RunRequest, opts *CreateRunOptions) (*schemas.Run, *client.Response, error) {
	httpResp, err := c.CreateRunRaw(ctx, req, opts)
	if err != nil {
		return nil, nil, err
	}
	defer httpResp.Body.Close()

	resp := &client.Response{Response: httpResp}

	var result struct {
		Data     schemas.Run              `json:"data"`
		Included []map[string]interface{} `json:"included"`
	}
	if err := json.NewDecoder(httpResp.Body).Decode(&result); err != nil {
		return nil, resp, fmt.Errorf("failed to decode response: %w", err)
	}

	// Populate included resources into relationships
	if len(result.Included) > 0 {
		result.Data.Relationships.PopulateIncludes(result.Included)
	}
	return &result.Data, resp, nil
}

// CreateRunOptions holds optional parameters for CreateRun
type CreateRunOptions struct {
	// The ID of VCS user who triggered the run. It is for the internal use only.
	VcsUserId int
	// The ID of a VCS task which triggered the run. Internal use only.
	VcsTaskId string
	Filter    map[string]string
}

// Skip any remaining work on runs that are paused waiting for confirmation or priority. This includes runs in the `pending`, `planned`, `policy_checked` and `policy_override` states.
func (c *Client) DiscardRunRaw(ctx context.Context, run string, req *schemas.Comment) (*http.Response, error) {
	path := "/runs/{run}/actions/discard"
	path = strings.ReplaceAll(path, "{run}", url.PathEscape(run))

	// Plain JSON request (not JSON:API)
	headers := map[string]string{"Content-Type": "application/json"}
	return c.httpClient.Post(ctx, path, req, headers)
}

// Skip any remaining work on runs that are paused waiting for confirmation or priority. This includes runs in the `pending`, `planned`, `policy_checked` and `policy_override` states.
func (c *Client) DiscardRun(ctx context.Context, run string, req *schemas.Comment) (*client.Response, error) {
	httpResp, err := c.DiscardRunRaw(ctx, run, req)
	if err != nil {
		return nil, err
	}
	defer httpResp.Body.Close()

	resp := &client.Response{Response: httpResp}

	return resp, nil
}

// Get a Zip archive with policy check input data generated for a given run. See [Policy Input](https://docs.scalr.io/docs/policy-as-code) data structure.
func (c *Client) DownloadPolicyInputRaw(ctx context.Context, run string, opts *DownloadPolicyInputOptions) (*http.Response, error) {
	path := "/runs/{run}/policy-input"
	path = strings.ReplaceAll(path, "{run}", url.PathEscape(run))

	params := url.Values{}
	if opts != nil {
		// Handle parameter: Stage (string)
		if opts.Stage != "" {
			params.Set("stage", opts.Stage)
		}
		// Add filters
		for k, v := range opts.Filter {
			params.Set("filter["+k+"]", v)
		}
	}
	if len(params) > 0 {
		path += "?" + params.Encode()
	}

	return c.httpClient.Get(ctx, path, nil)
}

// Get a Zip archive with policy check input data generated for a given run. See [Policy Input](https://docs.scalr.io/docs/policy-as-code) data structure.
func (c *Client) DownloadPolicyInput(ctx context.Context, run string, opts *DownloadPolicyInputOptions) (string, *client.Response, error) {
	httpResp, err := c.DownloadPolicyInputRaw(ctx, run, opts)
	if err != nil {
		return "", nil, err
	}
	defer httpResp.Body.Close()

	resp := &client.Response{Response: httpResp}

	bodyBytes, err := io.ReadAll(httpResp.Body)
	if err != nil {
		return "", resp, fmt.Errorf("failed to read response body: %w", err)
	}
	return string(bodyBytes), resp, nil
}

// DownloadPolicyInputOptions holds optional parameters for DownloadPolicyInput
type DownloadPolicyInputOptions struct {
	// The run stage
	Stage  string
	Filter map[string]string
}

// Cancel all previous runs in pending or waiting for confirmation statuses.
func (c *Client) ForceRunRaw(ctx context.Context, run string, req *schemas.Comment) (*http.Response, error) {
	path := "/runs/{run}/actions/force"
	path = strings.ReplaceAll(path, "{run}", url.PathEscape(run))

	// Plain JSON request (not JSON:API)
	headers := map[string]string{"Content-Type": "application/json"}
	return c.httpClient.Post(ctx, path, req, headers)
}

// Cancel all previous runs in pending or waiting for confirmation statuses.
func (c *Client) ForceRun(ctx context.Context, run string, req *schemas.Comment) (*client.Response, error) {
	httpResp, err := c.ForceRunRaw(ctx, run, req)
	if err != nil {
		return nil, err
	}
	defer httpResp.Body.Close()

	resp := &client.Response{Response: httpResp}

	return resp, nil
}

// Show details of a specific run.
func (c *Client) GetRunRaw(ctx context.Context, run string, opts *GetRunOptions) (*http.Response, error) {
	path := "/runs/{run}"
	path = strings.ReplaceAll(path, "{run}", url.PathEscape(run))

	params := url.Values{}
	if opts != nil {
		if len(opts.Include) > 0 {
			params.Set("include", strings.Join(opts.Include, ","))
		}
		// Handle parameter: Fields (map[string]interface{})
		// Complex type map[string]interface{} - skip for now
		// Add filters
		for k, v := range opts.Filter {
			params.Set("filter["+k+"]", v)
		}
	}
	if len(params) > 0 {
		path += "?" + params.Encode()
	}

	return c.httpClient.Get(ctx, path, nil)
}

// Show details of a specific run.
func (c *Client) GetRun(ctx context.Context, run string, opts *GetRunOptions) (*schemas.Run, *client.Response, error) {
	httpResp, err := c.GetRunRaw(ctx, run, opts)
	if err != nil {
		return nil, nil, err
	}
	defer httpResp.Body.Close()

	resp := &client.Response{Response: httpResp}

	var result struct {
		Data     schemas.Run              `json:"data"`
		Included []map[string]interface{} `json:"included"`
	}
	if err := json.NewDecoder(httpResp.Body).Decode(&result); err != nil {
		return nil, resp, fmt.Errorf("failed to decode response: %w", err)
	}

	// Populate included resources into relationships
	if len(result.Included) > 0 {
		result.Data.Relationships.PopulateIncludes(result.Included)
	}
	return &result.Data, resp, nil
}

// GetRunOptions holds optional parameters for GetRun
type GetRunOptions struct {
	// The comma-separated list of relationship paths.
	Include []string
	// The value of the fields[resource-type] parameter is a comma-separated list that refers to the name of the fields to be returned for the resource. An empty value indicates that no fields should be returned.
	Fields map[string]interface{}
	Filter map[string]string
}

// This endpoint lists runs for a specific workspace.
func (c *Client) GetRunsRaw(ctx context.Context, opts *GetRunsOptions) (*http.Response, error) {
	path := "/runs"

	params := url.Values{}
	if opts != nil {
		if opts.PageNumber > 0 {
			params.Set("page[number]", fmt.Sprintf("%d", opts.PageNumber))
		}
		if opts.PageSize > 0 {
			params.Set("page[size]", fmt.Sprintf("%d", opts.PageSize))
		}
		if len(opts.Include) > 0 {
			params.Set("include", strings.Join(opts.Include, ","))
		}
		// Handle parameter: Query (string)
		if opts.Query != "" {
			params.Set("query", opts.Query)
		}
		// Handle parameter: Scheduled (string)
		if opts.Scheduled != "" {
			params.Set("scheduled", opts.Scheduled)
		}
		// Handle parameter: Fields (map[string]interface{})
		// Complex type map[string]interface{} - skip for now
		// Add filters
		for k, v := range opts.Filter {
			params.Set("filter["+k+"]", v)
		}
	}
	if len(params) > 0 {
		path += "?" + params.Encode()
	}

	return c.httpClient.Get(ctx, path, nil)
}

// This endpoint lists runs for a specific workspace.
func (c *Client) GetRuns(ctx context.Context, opts *GetRunsOptions) ([]*schemas.Run, *client.Response, error) {
	httpResp, err := c.GetRunsRaw(ctx, opts)
	if err != nil {
		return nil, nil, err
	}
	defer httpResp.Body.Close()

	resp := &client.Response{Response: httpResp}

	var result struct {
		Data []schemas.Run `json:"data"`
		Meta struct {
			Pagination *client.Pagination `json:"pagination"`
		} `json:"meta"`
		Included []map[string]interface{} `json:"included"`
	}
	if err := json.NewDecoder(httpResp.Body).Decode(&result); err != nil {
		return nil, resp, fmt.Errorf("failed to decode response: %w", err)
	}

	resources := make([]*schemas.Run, len(result.Data))
	for i := range result.Data {
		resources[i] = &result.Data[i]
		// Populate included resources into relationships
		if len(result.Included) > 0 {
			resources[i].Relationships.PopulateIncludes(result.Included)
		}
	}
	resp.Pagination = result.Meta.Pagination
	return resources, resp, nil
}

// GetRunsIter returns an iterator for paginated results using Go 1.23+ range over iter.Seq2 feature.
// This is the recommended and simple way to iterate through all the results.
//
// The iterator automatically fetches pages as needed and handles errors inline.
//
// Example:
//
//	for item, err := range client.Run.GetRunsIter(ctx, opts) {
//	    if err != nil {
//	        return err
//	    }
//	    // Process item
//	}
func (c *Client) GetRunsIter(ctx context.Context, opts *GetRunsOptions) iter.Seq2[schemas.Run, error] {
	return func(yield func(schemas.Run, error) bool) {
		// Determine page size from opts or use default
		pageSize := 20
		if opts != nil && opts.PageSize > 0 {
			pageSize = opts.PageSize
		}

		pageNum := 1

		for {
			// Check context
			if err := ctx.Err(); err != nil {
				yield(schemas.Run{}, err)
				return
			}

			// Copy options and set page number
			pageOpts := &GetRunsOptions{}
			if opts != nil {
				*pageOpts = *opts
			}
			pageOpts.PageNumber = pageNum
			pageOpts.PageSize = pageSize

			// Fetch page
			items, resp, err := c.GetRuns(ctx, pageOpts)
			if err != nil {
				yield(schemas.Run{}, err)
				return
			}

			// Yield each item
			for _, item := range items {
				if !yield(*item, nil) {
					return // Consumer requested early exit
				}
			}

			// Check if there are more pages
			if resp.Pagination == nil || resp.Pagination.NextPage == nil {
				break
			}

			pageNum++
		}
	}
}

// GetRunsPaged returns a stateful iterator with access to pagination metadata.
// Use this when you need PageInfo(), Remaining(), or Collect() methods.
//
// Example:
//
//	iter := client.Run.GetRunsPaged(ctx, opts)
//	for iter.Next() {
//	    item := iter.Value()
//	    fmt.Print(iter.PageInfo()) // -> "page 2/5"
//	    fmt.Printf("%d items remaining", iter.Remaining())
//	}
//	if err := iter.Err(); err != nil {
//	    // Handle error
//	}
func (c *Client) GetRunsPaged(ctx context.Context, opts *GetRunsOptions) *client.Iterator[schemas.Run] {
	// Determine page size from opts or use default
	pageSize := 20
	if opts != nil && opts.PageSize > 0 {
		pageSize = opts.PageSize
	}

	// Fetch function that will be called for each page
	fetchPage := func(ctx context.Context, pageNum int) ([]*schemas.Run, *client.Pagination, error) {
		// Copy options and set page number
		pageOpts := &GetRunsOptions{}
		if opts != nil {
			*pageOpts = *opts
		}
		pageOpts.PageNumber = pageNum
		pageOpts.PageSize = pageSize

		// Call the actual list method
		items, resp, err := c.GetRuns(ctx, pageOpts)
		if err != nil {
			return nil, nil, err
		}

		return items, resp.Pagination, nil
	}

	return client.NewIterator[schemas.Run](ctx, pageSize, fetchPage)
}

// GetRunsOptions holds optional parameters for GetRuns
type GetRunsOptions struct {
	// Page number
	PageNumber int
	// Page size
	PageSize int
	// The comma-separated list of relationship paths.
	Include []string
	// Query string
	Query string
	// List only runs that are scheduled.
	Scheduled string
	// The value of the fields[resource-type] parameter is a comma-separated list that refers to the name of the fields to be returned for the resource. An empty value indicates that no fields should be returned.
	Fields map[string]interface{}
	Filter map[string]string
}

// This endpoint lists Runs Queue on allowed scopes.
func (c *Client) GetRunsQueueRaw(ctx context.Context, opts *GetRunsQueueOptions) (*http.Response, error) {
	path := "/runs-queue"

	params := url.Values{}
	if opts != nil {
		if opts.PageNumber > 0 {
			params.Set("page[number]", fmt.Sprintf("%d", opts.PageNumber))
		}
		if opts.PageSize > 0 {
			params.Set("page[size]", fmt.Sprintf("%d", opts.PageSize))
		}
		if len(opts.Include) > 0 {
			params.Set("include", strings.Join(opts.Include, ","))
		}
		// Handle parameter: Query (string)
		if opts.Query != "" {
			params.Set("query", opts.Query)
		}
		// Handle parameter: Scheduled (string)
		if opts.Scheduled != "" {
			params.Set("scheduled", opts.Scheduled)
		}
		// Handle parameter: Fields (map[string]interface{})
		// Complex type map[string]interface{} - skip for now
		// Add filters
		for k, v := range opts.Filter {
			params.Set("filter["+k+"]", v)
		}
	}
	if len(params) > 0 {
		path += "?" + params.Encode()
	}

	return c.httpClient.Get(ctx, path, nil)
}

// This endpoint lists Runs Queue on allowed scopes.
func (c *Client) GetRunsQueue(ctx context.Context, opts *GetRunsQueueOptions) ([]*schemas.Run, *client.Response, error) {
	httpResp, err := c.GetRunsQueueRaw(ctx, opts)
	if err != nil {
		return nil, nil, err
	}
	defer httpResp.Body.Close()

	resp := &client.Response{Response: httpResp}

	var result struct {
		Data []schemas.Run `json:"data"`
		Meta struct {
			Pagination *client.Pagination `json:"pagination"`
		} `json:"meta"`
		Included []map[string]interface{} `json:"included"`
	}
	if err := json.NewDecoder(httpResp.Body).Decode(&result); err != nil {
		return nil, resp, fmt.Errorf("failed to decode response: %w", err)
	}

	resources := make([]*schemas.Run, len(result.Data))
	for i := range result.Data {
		resources[i] = &result.Data[i]
		// Populate included resources into relationships
		if len(result.Included) > 0 {
			resources[i].Relationships.PopulateIncludes(result.Included)
		}
	}
	resp.Pagination = result.Meta.Pagination
	return resources, resp, nil
}

// GetRunsQueueIter returns an iterator for paginated results using Go 1.23+ range over iter.Seq2 feature.
// This is the recommended and simple way to iterate through all the results.
//
// The iterator automatically fetches pages as needed and handles errors inline.
//
// Example:
//
//	for item, err := range client.Run.GetRunsQueueIter(ctx, opts) {
//	    if err != nil {
//	        return err
//	    }
//	    // Process item
//	}
func (c *Client) GetRunsQueueIter(ctx context.Context, opts *GetRunsQueueOptions) iter.Seq2[schemas.Run, error] {
	return func(yield func(schemas.Run, error) bool) {
		// Determine page size from opts or use default
		pageSize := 20
		if opts != nil && opts.PageSize > 0 {
			pageSize = opts.PageSize
		}

		pageNum := 1

		for {
			// Check context
			if err := ctx.Err(); err != nil {
				yield(schemas.Run{}, err)
				return
			}

			// Copy options and set page number
			pageOpts := &GetRunsQueueOptions{}
			if opts != nil {
				*pageOpts = *opts
			}
			pageOpts.PageNumber = pageNum
			pageOpts.PageSize = pageSize

			// Fetch page
			items, resp, err := c.GetRunsQueue(ctx, pageOpts)
			if err != nil {
				yield(schemas.Run{}, err)
				return
			}

			// Yield each item
			for _, item := range items {
				if !yield(*item, nil) {
					return // Consumer requested early exit
				}
			}

			// Check if there are more pages
			if resp.Pagination == nil || resp.Pagination.NextPage == nil {
				break
			}

			pageNum++
		}
	}
}

// GetRunsQueuePaged returns a stateful iterator with access to pagination metadata.
// Use this when you need PageInfo(), Remaining(), or Collect() methods.
//
// Example:
//
//	iter := client.Run.GetRunsQueuePaged(ctx, opts)
//	for iter.Next() {
//	    item := iter.Value()
//	    fmt.Print(iter.PageInfo()) // -> "page 2/5"
//	    fmt.Printf("%d items remaining", iter.Remaining())
//	}
//	if err := iter.Err(); err != nil {
//	    // Handle error
//	}
func (c *Client) GetRunsQueuePaged(ctx context.Context, opts *GetRunsQueueOptions) *client.Iterator[schemas.Run] {
	// Determine page size from opts or use default
	pageSize := 20
	if opts != nil && opts.PageSize > 0 {
		pageSize = opts.PageSize
	}

	// Fetch function that will be called for each page
	fetchPage := func(ctx context.Context, pageNum int) ([]*schemas.Run, *client.Pagination, error) {
		// Copy options and set page number
		pageOpts := &GetRunsQueueOptions{}
		if opts != nil {
			*pageOpts = *opts
		}
		pageOpts.PageNumber = pageNum
		pageOpts.PageSize = pageSize

		// Call the actual list method
		items, resp, err := c.GetRunsQueue(ctx, pageOpts)
		if err != nil {
			return nil, nil, err
		}

		return items, resp.Pagination, nil
	}

	return client.NewIterator[schemas.Run](ctx, pageSize, fetchPage)
}

// GetRunsQueueOptions holds optional parameters for GetRunsQueue
type GetRunsQueueOptions struct {
	// Page number
	PageNumber int
	// Page size
	PageSize int
	// The comma-separated list of relationship paths.
	Include []string
	// Query string
	Query string
	// List only runs that are scheduled.
	Scheduled string
	// The value of the fields[resource-type] parameter is a comma-separated list that refers to the name of the fields to be returned for the resource. An empty value indicates that no fields should be returned.
	Fields map[string]interface{}
	Filter map[string]string
}
