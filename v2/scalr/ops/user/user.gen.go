// Code generated by scalr-gen. DO NOT EDIT.

package user

import (
	"context"
	"encoding/json"
	"fmt"
	"iter"
	"net/http"
	"net/url"
	"strings"

	"github.com/scalr/go-scalr/v2/scalr/client"
	"github.com/scalr/go-scalr/v2/scalr/schemas"
)

// Client provides access to User operations
type Client struct {
	httpClient *client.HTTPClient
}

// New creates a new User client
func New(httpClient *client.HTTPClient) *Client {
	return &Client{httpClient: httpClient}
}

// Create a new [IAM](https://docs.scalr.io/docs/identity-and-access-management) user without access to any account. To invite user to the account /accounts/:id/actions/invite should be used.
func (c *Client) CreateUserRaw(ctx context.Context, req *schemas.CreateUserRequest, opts *CreateUserOptions) (*http.Response, error) {
	path := "/users"

	params := url.Values{}
	if opts != nil {
		if len(opts.Include) > 0 {
			params.Set("include", strings.Join(opts.Include, ","))
		}
		// Add filters
		for k, v := range opts.Filter {
			params.Set("filter["+k+"]", v)
		}
	}
	if len(params) > 0 {
		path += "?" + params.Encode()
	}

	// Wrap request in JSON:API envelope
	body := map[string]interface{}{"data": req}
	return c.httpClient.Post(ctx, path, body, nil)
}

// Create a new [IAM](https://docs.scalr.io/docs/identity-and-access-management) user without access to any account. To invite user to the account /accounts/:id/actions/invite should be used.
func (c *Client) CreateUser(ctx context.Context, req *schemas.CreateUserRequest, opts *CreateUserOptions) (*schemas.CreateUser, *client.Response, error) {
	httpResp, err := c.CreateUserRaw(ctx, req, opts)
	if err != nil {
		return nil, nil, err
	}
	defer httpResp.Body.Close()

	resp := &client.Response{Response: httpResp}

	var result struct {
		Data     schemas.CreateUser       `json:"data"`
		Included []map[string]interface{} `json:"included"`
	}
	if err := json.NewDecoder(httpResp.Body).Decode(&result); err != nil {
		return nil, resp, fmt.Errorf("failed to decode response: %w", err)
	}

	// Populate included resources into relationships
	if len(result.Included) > 0 {
		result.Data.Relationships.PopulateIncludes(result.Included)
	}
	return &result.Data, resp, nil
}

// CreateUserOptions holds optional parameters for CreateUser
type CreateUserOptions struct {
	// The comma-separated list of relationship paths.
	Include []string
	Filter  map[string]string
}

// The endpoint deletes [IAM](https://docs.scalr.io/docs/identity-and-access-management) user by ID.
func (c *Client) DeleteUserRaw(ctx context.Context, user string) (*http.Response, error) {
	path := "/users/{user}"
	path = strings.ReplaceAll(path, "{user}", url.PathEscape(user))

	return c.httpClient.Delete(ctx, path, nil, nil)
}

// The endpoint deletes [IAM](https://docs.scalr.io/docs/identity-and-access-management) user by ID.
func (c *Client) DeleteUser(ctx context.Context, user string) (*client.Response, error) {
	httpResp, err := c.DeleteUserRaw(ctx, user)
	if err != nil {
		return nil, err
	}
	defer httpResp.Body.Close()

	resp := &client.Response{Response: httpResp}

	return resp, nil
}

// This endpoint returns a list of `AccountUser` resources. To get the list of accounts the user has access to, the `filter[user]` has to be specified. To get the list of users that have access to an account the `filter[account]` has to be specified.
func (c *Client) GetAccountUsersRaw(ctx context.Context, opts *GetAccountUsersOptions) (*http.Response, error) {
	path := "/account-users"

	params := url.Values{}
	if opts != nil {
		// Handle parameter: Query (string)
		if opts.Query != "" {
			params.Set("query", opts.Query)
		}
		if opts.PageNumber > 0 {
			params.Set("page[number]", fmt.Sprintf("%d", opts.PageNumber))
		}
		if opts.PageSize > 0 {
			params.Set("page[size]", fmt.Sprintf("%d", opts.PageSize))
		}
		if len(opts.Sort) > 0 {
			params.Set("sort", strings.Join(opts.Sort, ","))
		}
		if len(opts.Include) > 0 {
			params.Set("include", strings.Join(opts.Include, ","))
		}
		// Add filters
		for k, v := range opts.Filter {
			params.Set("filter["+k+"]", v)
		}
	}
	if len(params) > 0 {
		path += "?" + params.Encode()
	}

	return c.httpClient.Get(ctx, path, nil)
}

// This endpoint returns a list of `AccountUser` resources. To get the list of accounts the user has access to, the `filter[user]` has to be specified. To get the list of users that have access to an account the `filter[account]` has to be specified.
func (c *Client) GetAccountUsers(ctx context.Context, opts *GetAccountUsersOptions) ([]*schemas.AccountUser, *client.Response, error) {
	httpResp, err := c.GetAccountUsersRaw(ctx, opts)
	if err != nil {
		return nil, nil, err
	}
	defer httpResp.Body.Close()

	resp := &client.Response{Response: httpResp}

	var result struct {
		Data []schemas.AccountUser `json:"data"`
		Meta struct {
			Pagination *client.Pagination `json:"pagination"`
		} `json:"meta"`
		Included []map[string]interface{} `json:"included"`
	}
	if err := json.NewDecoder(httpResp.Body).Decode(&result); err != nil {
		return nil, resp, fmt.Errorf("failed to decode response: %w", err)
	}

	resources := make([]*schemas.AccountUser, len(result.Data))
	for i := range result.Data {
		resources[i] = &result.Data[i]
		// Populate included resources into relationships
		if len(result.Included) > 0 {
			resources[i].Relationships.PopulateIncludes(result.Included)
		}
	}
	resp.Pagination = result.Meta.Pagination
	return resources, resp, nil
}

// GetAccountUsersIter returns an iterator for paginated results using Go 1.23+ range over iter.Seq2 feature.
// This is the recommended and simple way to iterate through all the results.
//
// The iterator automatically fetches pages as needed and handles errors inline.
//
// Example:
//
//	for item, err := range client.User.GetAccountUsersIter(ctx, opts) {
//	    if err != nil {
//	        return err
//	    }
//	    // Process item
//	}
func (c *Client) GetAccountUsersIter(ctx context.Context, opts *GetAccountUsersOptions) iter.Seq2[schemas.AccountUser, error] {
	return func(yield func(schemas.AccountUser, error) bool) {
		// Determine page size from opts or use default
		pageSize := 20
		if opts != nil && opts.PageSize > 0 {
			pageSize = opts.PageSize
		}

		pageNum := 1

		for {
			// Check context
			if err := ctx.Err(); err != nil {
				yield(schemas.AccountUser{}, err)
				return
			}

			// Copy options and set page number
			pageOpts := &GetAccountUsersOptions{}
			if opts != nil {
				*pageOpts = *opts
			}
			pageOpts.PageNumber = pageNum
			pageOpts.PageSize = pageSize

			// Fetch page
			items, resp, err := c.GetAccountUsers(ctx, pageOpts)
			if err != nil {
				yield(schemas.AccountUser{}, err)
				return
			}

			// Yield each item
			for _, item := range items {
				if !yield(*item, nil) {
					return // Consumer requested early exit
				}
			}

			// Check if there are more pages
			if resp.Pagination == nil || resp.Pagination.NextPage == nil {
				break
			}

			pageNum++
		}
	}
}

// GetAccountUsersPaged returns a stateful iterator with access to pagination metadata.
// Use this when you need PageInfo(), Remaining(), or Collect() methods.
//
// Example:
//
//	iter := client.User.GetAccountUsersPaged(ctx, opts)
//	for iter.Next() {
//	    item := iter.Value()
//	    fmt.Print(iter.PageInfo()) // -> "page 2/5"
//	    fmt.Printf("%d items remaining", iter.Remaining())
//	}
//	if err := iter.Err(); err != nil {
//	    // Handle error
//	}
func (c *Client) GetAccountUsersPaged(ctx context.Context, opts *GetAccountUsersOptions) *client.Iterator[schemas.AccountUser] {
	// Determine page size from opts or use default
	pageSize := 20
	if opts != nil && opts.PageSize > 0 {
		pageSize = opts.PageSize
	}

	// Fetch function that will be called for each page
	fetchPage := func(ctx context.Context, pageNum int) ([]*schemas.AccountUser, *client.Pagination, error) {
		// Copy options and set page number
		pageOpts := &GetAccountUsersOptions{}
		if opts != nil {
			*pageOpts = *opts
		}
		pageOpts.PageNumber = pageNum
		pageOpts.PageSize = pageSize

		// Call the actual list method
		items, resp, err := c.GetAccountUsers(ctx, pageOpts)
		if err != nil {
			return nil, nil, err
		}

		return items, resp.Pagination, nil
	}

	return client.NewIterator[schemas.AccountUser](ctx, pageSize, fetchPage)
}

// GetAccountUsersOptions holds optional parameters for GetAccountUsers
type GetAccountUsersOptions struct {
	// Query string
	Query string
	// Page number
	PageNumber int
	// Page size
	PageSize int
	// The comma-separated list of attributes.
	Sort []string
	// The comma-separated list of relationship paths.
	Include []string
	Filter  map[string]string
}

// This endpoint returns an [IAM](https://docs.scalr.io/docs/identity-and-access-management) user by ID.
func (c *Client) GetUserRaw(ctx context.Context, user string, opts *GetUserOptions) (*http.Response, error) {
	path := "/users/{user}"
	path = strings.ReplaceAll(path, "{user}", url.PathEscape(user))

	params := url.Values{}
	if opts != nil {
		if len(opts.Include) > 0 {
			params.Set("include", strings.Join(opts.Include, ","))
		}
		// Add filters
		for k, v := range opts.Filter {
			params.Set("filter["+k+"]", v)
		}
	}
	if len(params) > 0 {
		path += "?" + params.Encode()
	}

	return c.httpClient.Get(ctx, path, nil)
}

// This endpoint returns an [IAM](https://docs.scalr.io/docs/identity-and-access-management) user by ID.
func (c *Client) GetUser(ctx context.Context, user string, opts *GetUserOptions) (*schemas.User, *client.Response, error) {
	httpResp, err := c.GetUserRaw(ctx, user, opts)
	if err != nil {
		return nil, nil, err
	}
	defer httpResp.Body.Close()

	resp := &client.Response{Response: httpResp}

	var result struct {
		Data     schemas.User             `json:"data"`
		Included []map[string]interface{} `json:"included"`
	}
	if err := json.NewDecoder(httpResp.Body).Decode(&result); err != nil {
		return nil, resp, fmt.Errorf("failed to decode response: %w", err)
	}

	// Populate included resources into relationships
	if len(result.Included) > 0 {
		result.Data.Relationships.PopulateIncludes(result.Included)
	}
	return &result.Data, resp, nil
}

// GetUserOptions holds optional parameters for GetUser
type GetUserOptions struct {
	// The comma-separated list of relationship paths.
	Include []string
	Filter  map[string]string
}

// This endpoint returns a list of [IAM](https://docs.scalr.io/docs/identity-and-access-management) users. The response can be filtered by IdP: `filter[identity-provider]` or user ID: `filter[user]`.
func (c *Client) GetUsersRaw(ctx context.Context, opts *GetUsersOptions) (*http.Response, error) {
	path := "/users"

	params := url.Values{}
	if opts != nil {
		if opts.PageNumber > 0 {
			params.Set("page[number]", fmt.Sprintf("%d", opts.PageNumber))
		}
		if opts.PageSize > 0 {
			params.Set("page[size]", fmt.Sprintf("%d", opts.PageSize))
		}
		if len(opts.Include) > 0 {
			params.Set("include", strings.Join(opts.Include, ","))
		}
		if len(opts.Sort) > 0 {
			params.Set("sort", strings.Join(opts.Sort, ","))
		}
		// Handle parameter: Query (string)
		if opts.Query != "" {
			params.Set("query", opts.Query)
		}
		// Handle parameter: AccessQuery (string)
		if opts.AccessQuery != "" {
			params.Set("access_query", opts.AccessQuery)
		}
		// Add filters
		for k, v := range opts.Filter {
			params.Set("filter["+k+"]", v)
		}
	}
	if len(params) > 0 {
		path += "?" + params.Encode()
	}

	return c.httpClient.Get(ctx, path, nil)
}

// This endpoint returns a list of [IAM](https://docs.scalr.io/docs/identity-and-access-management) users. The response can be filtered by IdP: `filter[identity-provider]` or user ID: `filter[user]`.
func (c *Client) GetUsers(ctx context.Context, opts *GetUsersOptions) ([]*schemas.User, *client.Response, error) {
	httpResp, err := c.GetUsersRaw(ctx, opts)
	if err != nil {
		return nil, nil, err
	}
	defer httpResp.Body.Close()

	resp := &client.Response{Response: httpResp}

	var result struct {
		Data []schemas.User `json:"data"`
		Meta struct {
			Pagination *client.Pagination `json:"pagination"`
		} `json:"meta"`
		Included []map[string]interface{} `json:"included"`
	}
	if err := json.NewDecoder(httpResp.Body).Decode(&result); err != nil {
		return nil, resp, fmt.Errorf("failed to decode response: %w", err)
	}

	resources := make([]*schemas.User, len(result.Data))
	for i := range result.Data {
		resources[i] = &result.Data[i]
		// Populate included resources into relationships
		if len(result.Included) > 0 {
			resources[i].Relationships.PopulateIncludes(result.Included)
		}
	}
	resp.Pagination = result.Meta.Pagination
	return resources, resp, nil
}

// GetUsersIter returns an iterator for paginated results using Go 1.23+ range over iter.Seq2 feature.
// This is the recommended and simple way to iterate through all the results.
//
// The iterator automatically fetches pages as needed and handles errors inline.
//
// Example:
//
//	for item, err := range client.User.GetUsersIter(ctx, opts) {
//	    if err != nil {
//	        return err
//	    }
//	    // Process item
//	}
func (c *Client) GetUsersIter(ctx context.Context, opts *GetUsersOptions) iter.Seq2[schemas.User, error] {
	return func(yield func(schemas.User, error) bool) {
		// Determine page size from opts or use default
		pageSize := 20
		if opts != nil && opts.PageSize > 0 {
			pageSize = opts.PageSize
		}

		pageNum := 1

		for {
			// Check context
			if err := ctx.Err(); err != nil {
				yield(schemas.User{}, err)
				return
			}

			// Copy options and set page number
			pageOpts := &GetUsersOptions{}
			if opts != nil {
				*pageOpts = *opts
			}
			pageOpts.PageNumber = pageNum
			pageOpts.PageSize = pageSize

			// Fetch page
			items, resp, err := c.GetUsers(ctx, pageOpts)
			if err != nil {
				yield(schemas.User{}, err)
				return
			}

			// Yield each item
			for _, item := range items {
				if !yield(*item, nil) {
					return // Consumer requested early exit
				}
			}

			// Check if there are more pages
			if resp.Pagination == nil || resp.Pagination.NextPage == nil {
				break
			}

			pageNum++
		}
	}
}

// GetUsersPaged returns a stateful iterator with access to pagination metadata.
// Use this when you need PageInfo(), Remaining(), or Collect() methods.
//
// Example:
//
//	iter := client.User.GetUsersPaged(ctx, opts)
//	for iter.Next() {
//	    item := iter.Value()
//	    fmt.Print(iter.PageInfo()) // -> "page 2/5"
//	    fmt.Printf("%d items remaining", iter.Remaining())
//	}
//	if err := iter.Err(); err != nil {
//	    // Handle error
//	}
func (c *Client) GetUsersPaged(ctx context.Context, opts *GetUsersOptions) *client.Iterator[schemas.User] {
	// Determine page size from opts or use default
	pageSize := 20
	if opts != nil && opts.PageSize > 0 {
		pageSize = opts.PageSize
	}

	// Fetch function that will be called for each page
	fetchPage := func(ctx context.Context, pageNum int) ([]*schemas.User, *client.Pagination, error) {
		// Copy options and set page number
		pageOpts := &GetUsersOptions{}
		if opts != nil {
			*pageOpts = *opts
		}
		pageOpts.PageNumber = pageNum
		pageOpts.PageSize = pageSize

		// Call the actual list method
		items, resp, err := c.GetUsers(ctx, pageOpts)
		if err != nil {
			return nil, nil, err
		}

		return items, resp.Pagination, nil
	}

	return client.NewIterator[schemas.User](ctx, pageSize, fetchPage)
}

// GetUsersOptions holds optional parameters for GetUsers
type GetUsersOptions struct {
	// Page number
	PageNumber int
	// Page size
	PageSize int
	// The comma-separated list of relationship paths.
	Include []string
	// The comma-separated list of attributes.
	Sort []string
	// Query string
	Query string
	// Query by access on given scope.
	AccessQuery string
	Filter      map[string]string
}

// Invite the user to the account by adding it to the account teams and/or creating access policies within the account. If the user with a specified email does not exist - a new one will be created. The new user will be in the 'pending' status until the first login to the account. This is the preferred way to create users.
func (c *Client) InviteUserToAccountRaw(ctx context.Context, account string, req *schemas.UserInviteRequest, opts *InviteUserToAccountOptions) (*http.Response, error) {
	path := "/accounts/{account}/actions/invite"
	path = strings.ReplaceAll(path, "{account}", url.PathEscape(account))

	params := url.Values{}
	if opts != nil {
		if len(opts.Include) > 0 {
			params.Set("include", strings.Join(opts.Include, ","))
		}
		// Add filters
		for k, v := range opts.Filter {
			params.Set("filter["+k+"]", v)
		}
	}
	if len(params) > 0 {
		path += "?" + params.Encode()
	}

	// Wrap request in JSON:API envelope
	body := map[string]interface{}{"data": req}
	return c.httpClient.Post(ctx, path, body, nil)
}

// Invite the user to the account by adding it to the account teams and/or creating access policies within the account. If the user with a specified email does not exist - a new one will be created. The new user will be in the 'pending' status until the first login to the account. This is the preferred way to create users.
func (c *Client) InviteUserToAccount(ctx context.Context, account string, req *schemas.UserInviteRequest, opts *InviteUserToAccountOptions) (*schemas.AccountUser, *client.Response, error) {
	httpResp, err := c.InviteUserToAccountRaw(ctx, account, req, opts)
	if err != nil {
		return nil, nil, err
	}
	defer httpResp.Body.Close()

	resp := &client.Response{Response: httpResp}

	var result struct {
		Data     schemas.AccountUser      `json:"data"`
		Included []map[string]interface{} `json:"included"`
	}
	if err := json.NewDecoder(httpResp.Body).Decode(&result); err != nil {
		return nil, resp, fmt.Errorf("failed to decode response: %w", err)
	}

	// Populate included resources into relationships
	if len(result.Included) > 0 {
		result.Data.Relationships.PopulateIncludes(result.Included)
	}
	return &result.Data, resp, nil
}

// InviteUserToAccountOptions holds optional parameters for InviteUserToAccount
type InviteUserToAccountOptions struct {
	// The comma-separated list of relationship paths.
	Include []string
	Filter  map[string]string
}

// The endpoint removes all user access policies and team bindings associated with the account.
func (c *Client) RemoveUserFromAccountRaw(ctx context.Context, account string, user string) (*http.Response, error) {
	path := "/accounts/{account}/actions/remove/{user}"
	path = strings.ReplaceAll(path, "{account}", url.PathEscape(account))
	path = strings.ReplaceAll(path, "{user}", url.PathEscape(user))

	return c.httpClient.Delete(ctx, path, nil, nil)
}

// The endpoint removes all user access policies and team bindings associated with the account.
func (c *Client) RemoveUserFromAccount(ctx context.Context, account string, user string) (*client.Response, error) {
	httpResp, err := c.RemoveUserFromAccountRaw(ctx, account, user)
	if err != nil {
		return nil, err
	}
	defer httpResp.Body.Close()

	resp := &client.Response{Response: httpResp}

	return resp, nil
}

// This endpoint updates [IAM](https://docs.scalr.io/docs/identity-and-access-management) user by ID.
func (c *Client) UpdateUserRaw(ctx context.Context, user string, req *schemas.UserRequest, opts *UpdateUserOptions) (*http.Response, error) {
	path := "/users/{user}"
	path = strings.ReplaceAll(path, "{user}", url.PathEscape(user))

	params := url.Values{}
	if opts != nil {
		if len(opts.Include) > 0 {
			params.Set("include", strings.Join(opts.Include, ","))
		}
		// Add filters
		for k, v := range opts.Filter {
			params.Set("filter["+k+"]", v)
		}
	}
	if len(params) > 0 {
		path += "?" + params.Encode()
	}

	// Wrap request in JSON:API envelope
	body := map[string]interface{}{"data": req}
	return c.httpClient.Patch(ctx, path, body, nil)
}

// This endpoint updates [IAM](https://docs.scalr.io/docs/identity-and-access-management) user by ID.
func (c *Client) UpdateUser(ctx context.Context, user string, req *schemas.UserRequest, opts *UpdateUserOptions) (*schemas.User, *client.Response, error) {
	httpResp, err := c.UpdateUserRaw(ctx, user, req, opts)
	if err != nil {
		return nil, nil, err
	}
	defer httpResp.Body.Close()

	resp := &client.Response{Response: httpResp}

	var result struct {
		Data     schemas.User             `json:"data"`
		Included []map[string]interface{} `json:"included"`
	}
	if err := json.NewDecoder(httpResp.Body).Decode(&result); err != nil {
		return nil, resp, fmt.Errorf("failed to decode response: %w", err)
	}

	// Populate included resources into relationships
	if len(result.Included) > 0 {
		result.Data.Relationships.PopulateIncludes(result.Included)
	}
	return &result.Data, resp, nil
}

// UpdateUserOptions holds optional parameters for UpdateUser
type UpdateUserOptions struct {
	// The comma-separated list of relationship paths.
	Include []string
	Filter  map[string]string
}
