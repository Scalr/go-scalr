// Code generated by scalr-gen. DO NOT EDIT.

package workspace

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"iter"
	"net/url"
	"strings"

	"github.com/scalr/go-scalr/v2/scalr/client"
	"github.com/scalr/go-scalr/v2/scalr/schemas"
)

// Client provides access to Workspace operations
type Client struct {
	httpClient *client.HTTPClient
}

// New creates a new Workspace client
func New(httpClient *client.HTTPClient) *Client {
	return &Client{httpClient: httpClient}
}

// This endpoint adds provided workspaces to a list of allowed remote state consumers for a given workspace.
func (c *Client) AddRemoteStateConsumersRaw(ctx context.Context, workspace string, req []schemas.Workspace) (*client.Response, error) {
	path := "/workspaces/{workspace}/relationships/remote-state-consumers"
	path = strings.ReplaceAll(path, "{workspace}", url.PathEscape(workspace))

	// This is a relationship operation - convert resources to relationship identifiers
	relationshipData := make([]map[string]interface{}, len(req))
	for i, item := range req {
		relationshipData[i] = map[string]interface{}{
			"id":   item.GetID(),
			"type": item.GetResourceType(),
		}
	}
	body := map[string]interface{}{"data": relationshipData}
	httpResp, err := c.httpClient.Post(ctx, path, body, nil)
	if err != nil {
		return nil, err
	}
	return &client.Response{Response: httpResp}, nil
}

// This endpoint adds provided workspaces to a list of allowed remote state consumers for a given workspace.
func (c *Client) AddRemoteStateConsumers(ctx context.Context, workspace string, req []schemas.Workspace) error {
	resp, err := c.AddRemoteStateConsumersRaw(ctx, workspace, req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	return nil
}

// This endpoint assigns the list of [tags](tags.html#the-tag-resource) to the workspace.
func (c *Client) AddWorkspaceTagsRaw(ctx context.Context, workspace string, req []schemas.Tag) (*client.Response, error) {
	path := "/workspaces/{workspace}/relationships/tags"
	path = strings.ReplaceAll(path, "{workspace}", url.PathEscape(workspace))

	// This is a relationship operation - convert resources to relationship identifiers
	relationshipData := make([]map[string]interface{}, len(req))
	for i, item := range req {
		relationshipData[i] = map[string]interface{}{
			"id":   item.GetID(),
			"type": item.GetResourceType(),
		}
	}
	body := map[string]interface{}{"data": relationshipData}
	httpResp, err := c.httpClient.Post(ctx, path, body, nil)
	if err != nil {
		return nil, err
	}
	return &client.Response{Response: httpResp}, nil
}

// This endpoint assigns the list of [tags](tags.html#the-tag-resource) to the workspace.
func (c *Client) AddWorkspaceTags(ctx context.Context, workspace string, req []schemas.Tag) error {
	resp, err := c.AddWorkspaceTagsRaw(ctx, workspace, req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	return nil
}

// Add a workspace to the current user's favorites.
func (c *Client) AddWorkspaceToFavoritesRaw(ctx context.Context, workspace string) (*client.Response, error) {
	path := "/workspaces/{workspace}/actions/favorite"
	path = strings.ReplaceAll(path, "{workspace}", url.PathEscape(workspace))

	httpResp, err := c.httpClient.Get(ctx, path, nil)
	if err != nil {
		return nil, err
	}
	return &client.Response{Response: httpResp}, nil
}

// Add a workspace to the current user's favorites.
func (c *Client) AddWorkspaceToFavorites(ctx context.Context, workspace string) (*schemas.Workspace, error) {
	resp, err := c.AddWorkspaceToFavoritesRaw(ctx, workspace)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var result struct {
		Data     schemas.Workspace        `json:"data"`
		Included []map[string]interface{} `json:"included"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	// Populate included resources into relationships
	if len(result.Included) > 0 {
		result.Data.Relationships.PopulateIncludes(result.Included)
	}
	return &result.Data, nil
}

// Workspaces represent a unit of infrastructure managed by terraform. To create a workspace you must pass `name` attribute and `environment` relationship. A workspace might be linked to a VCS repository, so that any git push will trigger a terraform Run in the workspace.
func (c *Client) CreateWorkspaceRaw(ctx context.Context, req *schemas.WorkspaceRequest) (*client.Response, error) {
	path := "/workspaces"

	// Wrap request in JSON:API envelope
	body := map[string]interface{}{"data": req}
	httpResp, err := c.httpClient.Post(ctx, path, body, nil)
	if err != nil {
		return nil, err
	}
	return &client.Response{Response: httpResp}, nil
}

// Workspaces represent a unit of infrastructure managed by terraform. To create a workspace you must pass `name` attribute and `environment` relationship. A workspace might be linked to a VCS repository, so that any git push will trigger a terraform Run in the workspace.
func (c *Client) CreateWorkspace(ctx context.Context, req *schemas.WorkspaceRequest) (*schemas.Workspace, error) {
	resp, err := c.CreateWorkspaceRaw(ctx, req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var result struct {
		Data     schemas.Workspace        `json:"data"`
		Included []map[string]interface{} `json:"included"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	// Populate included resources into relationships
	if len(result.Included) > 0 {
		result.Data.Relationships.PopulateIncludes(result.Included)
	}
	return &result.Data, nil
}

// This endpoint removes provided workspaces from a list of allowed remote state consumers for a given workspace.
func (c *Client) DeleteRemoteStateConsumersRaw(ctx context.Context, workspace string, req []schemas.Workspace) (*client.Response, error) {
	path := "/workspaces/{workspace}/relationships/remote-state-consumers"
	path = strings.ReplaceAll(path, "{workspace}", url.PathEscape(workspace))

	// This is a relationship operation - convert resources to relationship identifiers
	relationshipData := make([]map[string]interface{}, len(req))
	for i, item := range req {
		relationshipData[i] = map[string]interface{}{
			"id":   item.GetID(),
			"type": item.GetResourceType(),
		}
	}
	body := map[string]interface{}{"data": relationshipData}
	httpResp, err := c.httpClient.Delete(ctx, path, body, nil)
	if err != nil {
		return nil, err
	}
	return &client.Response{Response: httpResp}, nil
}

// This endpoint removes provided workspaces from a list of allowed remote state consumers for a given workspace.
func (c *Client) DeleteRemoteStateConsumers(ctx context.Context, workspace string, req []schemas.Workspace) error {
	resp, err := c.DeleteRemoteStateConsumersRaw(ctx, workspace, req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	return nil
}

func (c *Client) DeleteWorkspaceRaw(ctx context.Context, workspace string) (*client.Response, error) {
	path := "/workspaces/{workspace}"
	path = strings.ReplaceAll(path, "{workspace}", url.PathEscape(workspace))

	httpResp, err := c.httpClient.Delete(ctx, path, nil, nil)
	if err != nil {
		return nil, err
	}
	return &client.Response{Response: httpResp}, nil
}

func (c *Client) DeleteWorkspace(ctx context.Context, workspace string) error {
	resp, err := c.DeleteWorkspaceRaw(ctx, workspace)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	return nil
}

// This endpoint removes given [tags](tags.html#the-tag-resource) from the workspace.
func (c *Client) DeleteWorkspaceTagsRaw(ctx context.Context, workspace string, req []schemas.Tag) (*client.Response, error) {
	path := "/workspaces/{workspace}/relationships/tags"
	path = strings.ReplaceAll(path, "{workspace}", url.PathEscape(workspace))

	// This is a relationship operation - convert resources to relationship identifiers
	relationshipData := make([]map[string]interface{}, len(req))
	for i, item := range req {
		relationshipData[i] = map[string]interface{}{
			"id":   item.GetID(),
			"type": item.GetResourceType(),
		}
	}
	body := map[string]interface{}{"data": relationshipData}
	httpResp, err := c.httpClient.Delete(ctx, path, body, nil)
	if err != nil {
		return nil, err
	}
	return &client.Response{Response: httpResp}, nil
}

// This endpoint removes given [tags](tags.html#the-tag-resource) from the workspace.
func (c *Client) DeleteWorkspaceTags(ctx context.Context, workspace string, req []schemas.Tag) error {
	resp, err := c.DeleteWorkspaceTagsRaw(ctx, workspace, req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	return nil
}

// Show details of a specific workspace.
func (c *Client) GetWorkspaceRaw(ctx context.Context, workspace string, opts *GetWorkspaceOptions) (*client.Response, error) {
	path := "/workspaces/{workspace}"
	path = strings.ReplaceAll(path, "{workspace}", url.PathEscape(workspace))

	params := url.Values{}
	if opts != nil {
		if len(opts.Include) > 0 {
			params.Set("include", strings.Join(opts.Include, ","))
		}
		// Handle parameter: Fields (map[string]interface{})
		// Complex type map[string]interface{} - skip for now
		// Add filters
		for k, v := range opts.Filter {
			params.Set("filter["+k+"]", v)
		}
	}
	if len(params) > 0 {
		path += "?" + params.Encode()
	}

	httpResp, err := c.httpClient.Get(ctx, path, nil)
	if err != nil {
		return nil, err
	}
	return &client.Response{Response: httpResp}, nil
}

// Show details of a specific workspace.
func (c *Client) GetWorkspace(ctx context.Context, workspace string, opts *GetWorkspaceOptions) (*schemas.Workspace, error) {
	resp, err := c.GetWorkspaceRaw(ctx, workspace, opts)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var result struct {
		Data     schemas.Workspace        `json:"data"`
		Included []map[string]interface{} `json:"included"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	// Populate included resources into relationships
	if len(result.Included) > 0 {
		result.Data.Relationships.PopulateIncludes(result.Included)
	}
	return &result.Data, nil
}

// GetWorkspaceOptions holds optional parameters for GetWorkspace
type GetWorkspaceOptions struct {
	// The comma-separated list of relationship paths.
	Include []string
	// The value of the fields[resource-type] parameter is a comma-separated list that refers to the name of the fields to be returned for the resource. An empty value indicates that no fields should be returned.
	Fields map[string]interface{}
	Filter map[string]string
}

// This endpoint returns a list of outputs from current state version run output.
func (c *Client) GetWorkspaceOutputsRaw(ctx context.Context, workspace string) (*client.Response, error) {
	path := "/workspaces/{workspace}/outputs"
	path = strings.ReplaceAll(path, "{workspace}", url.PathEscape(workspace))

	httpResp, err := c.httpClient.Get(ctx, path, nil)
	if err != nil {
		return nil, err
	}
	return &client.Response{Response: httpResp}, nil
}

// This endpoint returns a list of outputs from current state version run output.
func (c *Client) GetWorkspaceOutputs(ctx context.Context, workspace string) (string, error) {
	resp, err := c.GetWorkspaceOutputsRaw(ctx, workspace)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("failed to read response body: %w", err)
	}
	return string(bodyBytes), nil
}

func (c *Client) GetWorkspacesRaw(ctx context.Context, opts *GetWorkspacesOptions) (*client.Response, error) {
	path := "/workspaces"

	params := url.Values{}
	if opts != nil {
		if opts.PageNumber > 0 {
			params.Set("page[number]", fmt.Sprintf("%d", opts.PageNumber))
		}
		if opts.PageSize > 0 {
			params.Set("page[size]", fmt.Sprintf("%d", opts.PageSize))
		}
		// Handle parameter: Query (string)
		if opts.Query != "" {
			params.Set("query", opts.Query)
		}
		// Handle parameter: SortFavoriteFirst (string)
		if opts.SortFavoriteFirst != "" {
			params.Set("sort[favorite-first]", opts.SortFavoriteFirst)
		}
		if len(opts.Include) > 0 {
			params.Set("include", strings.Join(opts.Include, ","))
		}
		if len(opts.Sort) > 0 {
			params.Set("sort", strings.Join(opts.Sort, ","))
		}
		// Handle parameter: Fields (map[string]interface{})
		// Complex type map[string]interface{} - skip for now
		// Add filters
		for k, v := range opts.Filter {
			params.Set("filter["+k+"]", v)
		}
	}
	if len(params) > 0 {
		path += "?" + params.Encode()
	}

	httpResp, err := c.httpClient.Get(ctx, path, nil)
	if err != nil {
		return nil, err
	}
	return &client.Response{Response: httpResp}, nil
}

func (c *Client) GetWorkspaces(ctx context.Context, opts *GetWorkspacesOptions) ([]*schemas.Workspace, error) {
	resp, err := c.GetWorkspacesRaw(ctx, opts)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var result struct {
		Data []schemas.Workspace `json:"data"`
		Meta struct {
			Pagination *client.Pagination `json:"pagination"`
		} `json:"meta"`
		Included []map[string]interface{} `json:"included"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	resources := make([]*schemas.Workspace, len(result.Data))
	for i := range result.Data {
		resources[i] = &result.Data[i]
		// Populate included resources into relationships
		if len(result.Included) > 0 {
			resources[i].Relationships.PopulateIncludes(result.Included)
		}
	}
	return resources, nil
}

// GetWorkspacesIter returns an iterator for paginated results using Go 1.23+ range over iter.Seq2 feature.
// This is the recommended and simple way to iterate through all the results.
//
// The iterator automatically fetches pages as needed and handles errors inline.
//
// Example:
//
//	for item, err := range client.Workspace.GetWorkspacesIter(ctx, opts) {
//	    if err != nil {
//	        return err
//	    }
//	    // Process item
//	}
func (c *Client) GetWorkspacesIter(ctx context.Context, opts *GetWorkspacesOptions) iter.Seq2[schemas.Workspace, error] {
	return func(yield func(schemas.Workspace, error) bool) {
		// Determine page size from opts or use default
		pageSize := 20
		if opts != nil && opts.PageSize > 0 {
			pageSize = opts.PageSize
		}

		pageNum := 1

		for {
			// Check context
			if err := ctx.Err(); err != nil {
				yield(schemas.Workspace{}, err)
				return
			}

			// Copy options and set page number
			pageOpts := &GetWorkspacesOptions{}
			if opts != nil {
				*pageOpts = *opts
			}
			pageOpts.PageNumber = pageNum
			pageOpts.PageSize = pageSize

			// Fetch page using Raw method to get pagination metadata
			resp, err := c.GetWorkspacesRaw(ctx, pageOpts)
			if err != nil {
				yield(schemas.Workspace{}, err)
				return
			}
			defer resp.Body.Close()

			// Decode response
			var result struct {
				Data []schemas.Workspace `json:"data"`
				Meta struct {
					Pagination *client.Pagination `json:"pagination"`
				} `json:"meta"`
				Included []map[string]interface{} `json:"included"`
			}
			if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
				yield(schemas.Workspace{}, fmt.Errorf("failed to decode response: %w", err))
				return
			}

			// Yield each item
			for i := range result.Data {
				// Populate included resources into relationships
				if len(result.Included) > 0 {
					result.Data[i].Relationships.PopulateIncludes(result.Included)
				}
				if !yield(result.Data[i], nil) {
					return // Consumer requested early exit
				}
			}

			// Check if there are more pages
			if result.Meta.Pagination == nil || result.Meta.Pagination.NextPage == nil {
				break
			}

			pageNum++
		}
	}
}

// GetWorkspacesPaged returns a stateful iterator with access to pagination metadata.
// Use this when you need PageInfo(), Remaining(), or Collect() methods.
//
// Example:
//
//	iter := client.Workspace.GetWorkspacesPaged(ctx, opts)
//	for iter.Next() {
//	    item := iter.Value()
//	    fmt.Print(iter.PageInfo()) // -> "page 2/5"
//	    fmt.Printf("%d items remaining", iter.Remaining())
//	}
//	if err := iter.Err(); err != nil {
//	    // Handle error
//	}
func (c *Client) GetWorkspacesPaged(ctx context.Context, opts *GetWorkspacesOptions) *client.Iterator[schemas.Workspace] {
	// Determine page size from opts or use default
	pageSize := 20
	if opts != nil && opts.PageSize > 0 {
		pageSize = opts.PageSize
	}

	// Fetch function that will be called for each page
	fetchPage := func(ctx context.Context, pageNum int) ([]*schemas.Workspace, *client.Pagination, error) {
		// Copy options and set page number
		pageOpts := &GetWorkspacesOptions{}
		if opts != nil {
			*pageOpts = *opts
		}
		pageOpts.PageNumber = pageNum
		pageOpts.PageSize = pageSize

		// Call the Raw method to get pagination metadata
		resp, err := c.GetWorkspacesRaw(ctx, pageOpts)
		if err != nil {
			return nil, nil, err
		}
		defer resp.Body.Close()

		// Decode response
		var result struct {
			Data []schemas.Workspace `json:"data"`
			Meta struct {
				Pagination *client.Pagination `json:"pagination"`
			} `json:"meta"`
			Included []map[string]interface{} `json:"included"`
		}
		if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
			return nil, nil, fmt.Errorf("failed to decode response: %w", err)
		}

		// Convert to slice of pointers and populate includes
		items := make([]*schemas.Workspace, len(result.Data))
		for i := range result.Data {
			items[i] = &result.Data[i]
			// Populate included resources into relationships
			if len(result.Included) > 0 {
				items[i].Relationships.PopulateIncludes(result.Included)
			}
		}

		return items, result.Meta.Pagination, nil
	}

	return client.NewIterator[schemas.Workspace](ctx, pageSize, fetchPage)
}

// GetWorkspacesOptions holds optional parameters for GetWorkspaces
type GetWorkspacesOptions struct {
	// Page number
	PageNumber int
	// Page size
	PageSize int
	// Query string, search by id, name.
	Query string
	// When set to 'true', favorite workspaces are shown first, followed by non-favorites. Both groups respect the main sort order.
	SortFavoriteFirst string
	// The comma-separated list of relationship paths.
	Include []string
	// The comma-separated list of attributes.
	Sort []string
	// The value of the fields[resource-type] parameter is a comma-separated list that refers to the name of the fields to be returned for the resource. An empty value indicates that no fields should be returned.
	Fields map[string]interface{}
	Filter map[string]string
}

// This endpoint returns a list of other workspaces that that were explicitly added as state consumers for given workspace.
func (c *Client) ListRemoteStateConsumersRaw(ctx context.Context, workspace string, opts *ListRemoteStateConsumersOptions) (*client.Response, error) {
	path := "/workspaces/{workspace}/relationships/remote-state-consumers"
	path = strings.ReplaceAll(path, "{workspace}", url.PathEscape(workspace))

	params := url.Values{}
	if opts != nil {
		if opts.PageNumber > 0 {
			params.Set("page[number]", fmt.Sprintf("%d", opts.PageNumber))
		}
		if opts.PageSize > 0 {
			params.Set("page[size]", fmt.Sprintf("%d", opts.PageSize))
		}
		// Add filters
		for k, v := range opts.Filter {
			params.Set("filter["+k+"]", v)
		}
	}
	if len(params) > 0 {
		path += "?" + params.Encode()
	}

	httpResp, err := c.httpClient.Get(ctx, path, nil)
	if err != nil {
		return nil, err
	}
	return &client.Response{Response: httpResp}, nil
}

// This endpoint returns a list of other workspaces that that were explicitly added as state consumers for given workspace.
func (c *Client) ListRemoteStateConsumers(ctx context.Context, workspace string, opts *ListRemoteStateConsumersOptions) ([]*schemas.Workspace, error) {
	resp, err := c.ListRemoteStateConsumersRaw(ctx, workspace, opts)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var result struct {
		Data []schemas.Workspace `json:"data"`
		Meta struct {
			Pagination *client.Pagination `json:"pagination"`
		} `json:"meta"`
		Included []map[string]interface{} `json:"included"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	resources := make([]*schemas.Workspace, len(result.Data))
	for i := range result.Data {
		resources[i] = &result.Data[i]
	}
	return resources, nil
}

// ListRemoteStateConsumersIter returns an iterator for paginated results using Go 1.23+ range over iter.Seq2 feature.
// This is the recommended and simple way to iterate through all the results.
//
// The iterator automatically fetches pages as needed and handles errors inline.
//
// Example:
//
//	for item, err := range client.Workspace.ListRemoteStateConsumersIter(ctx, workspace, opts) {
//	    if err != nil {
//	        return err
//	    }
//	    // Process item
//	}
func (c *Client) ListRemoteStateConsumersIter(ctx context.Context, workspace string, opts *ListRemoteStateConsumersOptions) iter.Seq2[schemas.Workspace, error] {
	return func(yield func(schemas.Workspace, error) bool) {
		// Determine page size from opts or use default
		pageSize := 20
		if opts != nil && opts.PageSize > 0 {
			pageSize = opts.PageSize
		}

		pageNum := 1

		for {
			// Check context
			if err := ctx.Err(); err != nil {
				yield(schemas.Workspace{}, err)
				return
			}

			// Copy options and set page number
			pageOpts := &ListRemoteStateConsumersOptions{}
			if opts != nil {
				*pageOpts = *opts
			}
			pageOpts.PageNumber = pageNum
			pageOpts.PageSize = pageSize

			// Fetch page using Raw method to get pagination metadata
			resp, err := c.ListRemoteStateConsumersRaw(ctx, workspace, pageOpts)
			if err != nil {
				yield(schemas.Workspace{}, err)
				return
			}
			defer resp.Body.Close()

			// Decode response
			var result struct {
				Data []schemas.Workspace `json:"data"`
				Meta struct {
					Pagination *client.Pagination `json:"pagination"`
				} `json:"meta"`
				Included []map[string]interface{} `json:"included"`
			}
			if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
				yield(schemas.Workspace{}, fmt.Errorf("failed to decode response: %w", err))
				return
			}

			// Yield each item
			for i := range result.Data {
				if !yield(result.Data[i], nil) {
					return // Consumer requested early exit
				}
			}

			// Check if there are more pages
			if result.Meta.Pagination == nil || result.Meta.Pagination.NextPage == nil {
				break
			}

			pageNum++
		}
	}
}

// ListRemoteStateConsumersPaged returns a stateful iterator with access to pagination metadata.
// Use this when you need PageInfo(), Remaining(), or Collect() methods.
//
// Example:
//
//	iter := client.Workspace.ListRemoteStateConsumersPaged(ctx, workspace, opts)
//	for iter.Next() {
//	    item := iter.Value()
//	    fmt.Print(iter.PageInfo()) // -> "page 2/5"
//	    fmt.Printf("%d items remaining", iter.Remaining())
//	}
//	if err := iter.Err(); err != nil {
//	    // Handle error
//	}
func (c *Client) ListRemoteStateConsumersPaged(ctx context.Context, workspace string, opts *ListRemoteStateConsumersOptions) *client.Iterator[schemas.Workspace] {
	// Determine page size from opts or use default
	pageSize := 20
	if opts != nil && opts.PageSize > 0 {
		pageSize = opts.PageSize
	}

	// Fetch function that will be called for each page
	fetchPage := func(ctx context.Context, pageNum int) ([]*schemas.Workspace, *client.Pagination, error) {
		// Copy options and set page number
		pageOpts := &ListRemoteStateConsumersOptions{}
		if opts != nil {
			*pageOpts = *opts
		}
		pageOpts.PageNumber = pageNum
		pageOpts.PageSize = pageSize

		// Call the Raw method to get pagination metadata
		resp, err := c.ListRemoteStateConsumersRaw(ctx, workspace, pageOpts)
		if err != nil {
			return nil, nil, err
		}
		defer resp.Body.Close()

		// Decode response
		var result struct {
			Data []schemas.Workspace `json:"data"`
			Meta struct {
				Pagination *client.Pagination `json:"pagination"`
			} `json:"meta"`
			Included []map[string]interface{} `json:"included"`
		}
		if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
			return nil, nil, fmt.Errorf("failed to decode response: %w", err)
		}

		// Convert to slice of pointers and populate includes
		items := make([]*schemas.Workspace, len(result.Data))
		for i := range result.Data {
			items[i] = &result.Data[i]
		}

		return items, result.Meta.Pagination, nil
	}

	return client.NewIterator[schemas.Workspace](ctx, pageSize, fetchPage)
}

// ListRemoteStateConsumersOptions holds optional parameters for ListRemoteStateConsumers
type ListRemoteStateConsumersOptions struct {
	// Page number
	PageNumber int
	// Page size
	PageSize int
	Filter   map[string]string
}

// This endpoint returns a list of [tags](tags.html#the-tag-resource), assigned to a workspace.
func (c *Client) ListWorkspaceTagsRaw(ctx context.Context, workspace string, opts *ListWorkspaceTagsOptions) (*client.Response, error) {
	path := "/workspaces/{workspace}/relationships/tags"
	path = strings.ReplaceAll(path, "{workspace}", url.PathEscape(workspace))

	params := url.Values{}
	if opts != nil {
		if opts.PageNumber > 0 {
			params.Set("page[number]", fmt.Sprintf("%d", opts.PageNumber))
		}
		if opts.PageSize > 0 {
			params.Set("page[size]", fmt.Sprintf("%d", opts.PageSize))
		}
		// Add filters
		for k, v := range opts.Filter {
			params.Set("filter["+k+"]", v)
		}
	}
	if len(params) > 0 {
		path += "?" + params.Encode()
	}

	httpResp, err := c.httpClient.Get(ctx, path, nil)
	if err != nil {
		return nil, err
	}
	return &client.Response{Response: httpResp}, nil
}

// This endpoint returns a list of [tags](tags.html#the-tag-resource), assigned to a workspace.
func (c *Client) ListWorkspaceTags(ctx context.Context, workspace string, opts *ListWorkspaceTagsOptions) ([]*schemas.Tag, error) {
	resp, err := c.ListWorkspaceTagsRaw(ctx, workspace, opts)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var result struct {
		Data []schemas.Tag `json:"data"`
		Meta struct {
			Pagination *client.Pagination `json:"pagination"`
		} `json:"meta"`
		Included []map[string]interface{} `json:"included"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	resources := make([]*schemas.Tag, len(result.Data))
	for i := range result.Data {
		resources[i] = &result.Data[i]
	}
	return resources, nil
}

// ListWorkspaceTagsIter returns an iterator for paginated results using Go 1.23+ range over iter.Seq2 feature.
// This is the recommended and simple way to iterate through all the results.
//
// The iterator automatically fetches pages as needed and handles errors inline.
//
// Example:
//
//	for item, err := range client.Workspace.ListWorkspaceTagsIter(ctx, workspace, opts) {
//	    if err != nil {
//	        return err
//	    }
//	    // Process item
//	}
func (c *Client) ListWorkspaceTagsIter(ctx context.Context, workspace string, opts *ListWorkspaceTagsOptions) iter.Seq2[schemas.Tag, error] {
	return func(yield func(schemas.Tag, error) bool) {
		// Determine page size from opts or use default
		pageSize := 20
		if opts != nil && opts.PageSize > 0 {
			pageSize = opts.PageSize
		}

		pageNum := 1

		for {
			// Check context
			if err := ctx.Err(); err != nil {
				yield(schemas.Tag{}, err)
				return
			}

			// Copy options and set page number
			pageOpts := &ListWorkspaceTagsOptions{}
			if opts != nil {
				*pageOpts = *opts
			}
			pageOpts.PageNumber = pageNum
			pageOpts.PageSize = pageSize

			// Fetch page using Raw method to get pagination metadata
			resp, err := c.ListWorkspaceTagsRaw(ctx, workspace, pageOpts)
			if err != nil {
				yield(schemas.Tag{}, err)
				return
			}
			defer resp.Body.Close()

			// Decode response
			var result struct {
				Data []schemas.Tag `json:"data"`
				Meta struct {
					Pagination *client.Pagination `json:"pagination"`
				} `json:"meta"`
				Included []map[string]interface{} `json:"included"`
			}
			if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
				yield(schemas.Tag{}, fmt.Errorf("failed to decode response: %w", err))
				return
			}

			// Yield each item
			for i := range result.Data {
				if !yield(result.Data[i], nil) {
					return // Consumer requested early exit
				}
			}

			// Check if there are more pages
			if result.Meta.Pagination == nil || result.Meta.Pagination.NextPage == nil {
				break
			}

			pageNum++
		}
	}
}

// ListWorkspaceTagsPaged returns a stateful iterator with access to pagination metadata.
// Use this when you need PageInfo(), Remaining(), or Collect() methods.
//
// Example:
//
//	iter := client.Workspace.ListWorkspaceTagsPaged(ctx, workspace, opts)
//	for iter.Next() {
//	    item := iter.Value()
//	    fmt.Print(iter.PageInfo()) // -> "page 2/5"
//	    fmt.Printf("%d items remaining", iter.Remaining())
//	}
//	if err := iter.Err(); err != nil {
//	    // Handle error
//	}
func (c *Client) ListWorkspaceTagsPaged(ctx context.Context, workspace string, opts *ListWorkspaceTagsOptions) *client.Iterator[schemas.Tag] {
	// Determine page size from opts or use default
	pageSize := 20
	if opts != nil && opts.PageSize > 0 {
		pageSize = opts.PageSize
	}

	// Fetch function that will be called for each page
	fetchPage := func(ctx context.Context, pageNum int) ([]*schemas.Tag, *client.Pagination, error) {
		// Copy options and set page number
		pageOpts := &ListWorkspaceTagsOptions{}
		if opts != nil {
			*pageOpts = *opts
		}
		pageOpts.PageNumber = pageNum
		pageOpts.PageSize = pageSize

		// Call the Raw method to get pagination metadata
		resp, err := c.ListWorkspaceTagsRaw(ctx, workspace, pageOpts)
		if err != nil {
			return nil, nil, err
		}
		defer resp.Body.Close()

		// Decode response
		var result struct {
			Data []schemas.Tag `json:"data"`
			Meta struct {
				Pagination *client.Pagination `json:"pagination"`
			} `json:"meta"`
			Included []map[string]interface{} `json:"included"`
		}
		if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
			return nil, nil, fmt.Errorf("failed to decode response: %w", err)
		}

		// Convert to slice of pointers and populate includes
		items := make([]*schemas.Tag, len(result.Data))
		for i := range result.Data {
			items[i] = &result.Data[i]
		}

		return items, result.Meta.Pagination, nil
	}

	return client.NewIterator[schemas.Tag](ctx, pageSize, fetchPage)
}

// ListWorkspaceTagsOptions holds optional parameters for ListWorkspaceTags
type ListWorkspaceTagsOptions struct {
	// Page number
	PageNumber int
	// Page size
	PageSize int
	Filter   map[string]string
}

// This endpoint locks a workspace.
func (c *Client) LockWorkspaceRaw(ctx context.Context, workspace string, req *schemas.Reason) (*client.Response, error) {
	path := "/workspaces/{workspace}/actions/lock"
	path = strings.ReplaceAll(path, "{workspace}", url.PathEscape(workspace))

	// Plain JSON request (not JSON:API)
	headers := map[string]string{"Content-Type": "application/json"}
	httpResp, err := c.httpClient.Post(ctx, path, req, headers)
	if err != nil {
		return nil, err
	}
	return &client.Response{Response: httpResp}, nil
}

// This endpoint locks a workspace.
func (c *Client) LockWorkspace(ctx context.Context, workspace string, req *schemas.Reason) (*schemas.Workspace, error) {
	resp, err := c.LockWorkspaceRaw(ctx, workspace, req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var result struct {
		Data     schemas.Workspace        `json:"data"`
		Included []map[string]interface{} `json:"included"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	// Populate included resources into relationships
	if len(result.Included) > 0 {
		result.Data.Relationships.PopulateIncludes(result.Included)
	}
	return &result.Data, nil
}

// Remove a workspace from the current user's favorites.
func (c *Client) RemoveWorkspaceFromFavoritesRaw(ctx context.Context, workspace string) (*client.Response, error) {
	path := "/workspaces/{workspace}/actions/unfavorite"
	path = strings.ReplaceAll(path, "{workspace}", url.PathEscape(workspace))

	httpResp, err := c.httpClient.Get(ctx, path, nil)
	if err != nil {
		return nil, err
	}
	return &client.Response{Response: httpResp}, nil
}

// Remove a workspace from the current user's favorites.
func (c *Client) RemoveWorkspaceFromFavorites(ctx context.Context, workspace string) (*schemas.Workspace, error) {
	resp, err := c.RemoveWorkspaceFromFavoritesRaw(ctx, workspace)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var result struct {
		Data     schemas.Workspace        `json:"data"`
		Included []map[string]interface{} `json:"included"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	// Populate included resources into relationships
	if len(result.Included) > 0 {
		result.Data.Relationships.PopulateIncludes(result.Included)
	}
	return &result.Data, nil
}

// This endpoint replaces a list of allowed remote state consumers for a given workspace.
func (c *Client) ReplaceRemoteStateConsumersRaw(ctx context.Context, workspace string, req []schemas.Workspace) (*client.Response, error) {
	path := "/workspaces/{workspace}/relationships/remote-state-consumers"
	path = strings.ReplaceAll(path, "{workspace}", url.PathEscape(workspace))

	// This is a relationship operation - convert resources to relationship identifiers
	relationshipData := make([]map[string]interface{}, len(req))
	for i, item := range req {
		relationshipData[i] = map[string]interface{}{
			"id":   item.GetID(),
			"type": item.GetResourceType(),
		}
	}
	body := map[string]interface{}{"data": relationshipData}
	httpResp, err := c.httpClient.Patch(ctx, path, body, nil)
	if err != nil {
		return nil, err
	}
	return &client.Response{Response: httpResp}, nil
}

// This endpoint replaces a list of allowed remote state consumers for a given workspace.
func (c *Client) ReplaceRemoteStateConsumers(ctx context.Context, workspace string, req []schemas.Workspace) error {
	resp, err := c.ReplaceRemoteStateConsumersRaw(ctx, workspace, req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	return nil
}

// This endpoint completely replaces workspace's tags with provided list.
func (c *Client) ReplaceWorkspaceTagsRaw(ctx context.Context, workspace string, req []schemas.Tag) (*client.Response, error) {
	path := "/workspaces/{workspace}/relationships/tags"
	path = strings.ReplaceAll(path, "{workspace}", url.PathEscape(workspace))

	// This is a relationship operation - convert resources to relationship identifiers
	relationshipData := make([]map[string]interface{}, len(req))
	for i, item := range req {
		relationshipData[i] = map[string]interface{}{
			"id":   item.GetID(),
			"type": item.GetResourceType(),
		}
	}
	body := map[string]interface{}{"data": relationshipData}
	httpResp, err := c.httpClient.Patch(ctx, path, body, nil)
	if err != nil {
		return nil, err
	}
	return &client.Response{Response: httpResp}, nil
}

// This endpoint completely replaces workspace's tags with provided list.
func (c *Client) ReplaceWorkspaceTags(ctx context.Context, workspace string, req []schemas.Tag) error {
	resp, err := c.ReplaceWorkspaceTagsRaw(ctx, workspace, req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	return nil
}

// This endpoint triggers a Configuration Version resync for a Workspace associated with a VCS repository.
func (c *Client) ResyncWorkspaceRaw(ctx context.Context, workspace string) (*client.Response, error) {
	path := "/workspaces/{workspace}/actions/resync"
	path = strings.ReplaceAll(path, "{workspace}", url.PathEscape(workspace))

	httpResp, err := c.httpClient.Get(ctx, path, nil)
	if err != nil {
		return nil, err
	}
	return &client.Response{Response: httpResp}, nil
}

// This endpoint triggers a Configuration Version resync for a Workspace associated with a VCS repository.
func (c *Client) ResyncWorkspace(ctx context.Context, workspace string) (*schemas.ConfigurationVersion, error) {
	resp, err := c.ResyncWorkspaceRaw(ctx, workspace)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var result struct {
		Data     schemas.ConfigurationVersion `json:"data"`
		Included []map[string]interface{}     `json:"included"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	// Populate included resources into relationships
	if len(result.Included) > 0 {
		result.Data.Relationships.PopulateIncludes(result.Included)
	}
	return &result.Data, nil
}

func (c *Client) SetScheduleRaw(ctx context.Context, workspace string, req *schemas.WorkspaceSchedule) (*client.Response, error) {
	path := "/workspaces/{workspace}/actions/set-schedule"
	path = strings.ReplaceAll(path, "{workspace}", url.PathEscape(workspace))

	// Plain JSON request (not JSON:API)
	headers := map[string]string{"Content-Type": "application/json"}
	httpResp, err := c.httpClient.Post(ctx, path, req, headers)
	if err != nil {
		return nil, err
	}
	return &client.Response{Response: httpResp}, nil
}

func (c *Client) SetSchedule(ctx context.Context, workspace string, req *schemas.WorkspaceSchedule) (*schemas.Workspace, error) {
	resp, err := c.SetScheduleRaw(ctx, workspace, req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var result struct {
		Data     schemas.Workspace        `json:"data"`
		Included []map[string]interface{} `json:"included"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	// Populate included resources into relationships
	if len(result.Included) > 0 {
		result.Data.Relationships.PopulateIncludes(result.Included)
	}
	return &result.Data, nil
}

// This endpoint unlocks a workspace.
func (c *Client) UnlockWorkspaceRaw(ctx context.Context, workspace string) (*client.Response, error) {
	path := "/workspaces/{workspace}/actions/unlock"
	path = strings.ReplaceAll(path, "{workspace}", url.PathEscape(workspace))

	httpResp, err := c.httpClient.Get(ctx, path, nil)
	if err != nil {
		return nil, err
	}
	return &client.Response{Response: httpResp}, nil
}

// This endpoint unlocks a workspace.
func (c *Client) UnlockWorkspace(ctx context.Context, workspace string) (*schemas.Workspace, error) {
	resp, err := c.UnlockWorkspaceRaw(ctx, workspace)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var result struct {
		Data     schemas.Workspace        `json:"data"`
		Included []map[string]interface{} `json:"included"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	// Populate included resources into relationships
	if len(result.Included) > 0 {
		result.Data.Relationships.PopulateIncludes(result.Included)
	}
	return &result.Data, nil
}

func (c *Client) UpdateWorkspaceRaw(ctx context.Context, workspace string, req *schemas.WorkspaceRequest) (*client.Response, error) {
	path := "/workspaces/{workspace}"
	path = strings.ReplaceAll(path, "{workspace}", url.PathEscape(workspace))

	// Wrap request in JSON:API envelope
	body := map[string]interface{}{"data": req}
	httpResp, err := c.httpClient.Patch(ctx, path, body, nil)
	if err != nil {
		return nil, err
	}
	return &client.Response{Response: httpResp}, nil
}

func (c *Client) UpdateWorkspace(ctx context.Context, workspace string, req *schemas.WorkspaceRequest) (*schemas.Workspace, error) {
	resp, err := c.UpdateWorkspaceRaw(ctx, workspace, req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var result struct {
		Data     schemas.Workspace        `json:"data"`
		Included []map[string]interface{} `json:"included"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	// Populate included resources into relationships
	if len(result.Included) > 0 {
		result.Data.Relationships.PopulateIncludes(result.Included)
	}
	return &result.Data, nil
}
