// Code generated by scalr-gen. DO NOT EDIT.

package misc

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/scalr/go-scalr/v2/scalr/client"
	"github.com/scalr/go-scalr/v2/scalr/schemas"
)

// Client provides access to Misc operations
type Client struct {
	httpClient *client.HTTPClient
}

// New creates a new Misc client
func New(httpClient *client.HTTPClient) *Client {
	return &Client{httpClient: httpClient}
}

func (c *Client) CreateVcsTaskRaw(ctx context.Context, req *schemas.VcsTaskRequest) (*http.Response, error) {
	path := "/vcs-tasks"

	// Plain JSON request (not JSON:API)
	headers := map[string]string{"Content-Type": "application/json"}
	return c.httpClient.Post(ctx, path, req, headers)
}

func (c *Client) CreateVcsTask(ctx context.Context, req *schemas.VcsTaskRequest) (*client.Response, error) {
	httpResp, err := c.CreateVcsTaskRaw(ctx, req)
	if err != nil {
		return nil, err
	}
	defer httpResp.Body.Close()

	resp := &client.Response{Response: httpResp}

	return resp, nil
}

// Creates a link between a workspace and an SSH key.
func (c *Client) CreateWorkspaceSshKeyLinkRaw(ctx context.Context, workspace string, req *schemas.WorkspaceSSHKeyLinkRequest) (*http.Response, error) {
	path := "/workspaces/{workspace}/ssh-key-links"
	path = strings.ReplaceAll(path, "{workspace}", url.PathEscape(workspace))

	// Plain JSON request (not JSON:API)
	headers := map[string]string{"Content-Type": "application/json"}
	return c.httpClient.Post(ctx, path, req, headers)
}

// Creates a link between a workspace and an SSH key.
func (c *Client) CreateWorkspaceSshKeyLink(ctx context.Context, workspace string, req *schemas.WorkspaceSSHKeyLinkRequest) (*schemas.Workspace, *client.Response, error) {
	httpResp, err := c.CreateWorkspaceSshKeyLinkRaw(ctx, workspace, req)
	if err != nil {
		return nil, nil, err
	}
	defer httpResp.Body.Close()

	resp := &client.Response{Response: httpResp}

	var result struct {
		Data     schemas.Workspace        `json:"data"`
		Included []map[string]interface{} `json:"included"`
	}
	if err := json.NewDecoder(httpResp.Body).Decode(&result); err != nil {
		return nil, resp, fmt.Errorf("failed to decode response: %w", err)
	}

	// Populate included resources into relationships
	if len(result.Included) > 0 {
		result.Data.Relationships.PopulateIncludes(result.Included)
	}
	return &result.Data, resp, nil
}

// Deletes a link between a workspace and an SSH key.
func (c *Client) DeleteWorkspaceSshKeyLinkRaw(ctx context.Context, workspace string) (*http.Response, error) {
	path := "/workspaces/{workspace}/ssh-key-links"
	path = strings.ReplaceAll(path, "{workspace}", url.PathEscape(workspace))

	return c.httpClient.Delete(ctx, path, nil)
}

// Deletes a link between a workspace and an SSH key.
func (c *Client) DeleteWorkspaceSshKeyLink(ctx context.Context, workspace string) (*client.Response, error) {
	httpResp, err := c.DeleteWorkspaceSshKeyLinkRaw(ctx, workspace)
	if err != nil {
		return nil, err
	}
	defer httpResp.Body.Close()

	resp := &client.Response{Response: httpResp}

	return resp, nil
}

func (c *Client) GetOpenMetricsRaw(ctx context.Context) (*http.Response, error) {
	path := "/metrics"

	return c.httpClient.Get(ctx, path, nil)
}

func (c *Client) GetOpenMetrics(ctx context.Context) (string, *client.Response, error) {
	httpResp, err := c.GetOpenMetricsRaw(ctx)
	if err != nil {
		return "", nil, err
	}
	defer httpResp.Body.Close()

	resp := &client.Response{Response: httpResp}

	bodyBytes, err := io.ReadAll(httpResp.Body)
	if err != nil {
		return "", resp, fmt.Errorf("failed to read response body: %w", err)
	}
	return string(bodyBytes), resp, nil
}

// Destroys user's session. In case of the SAML additionally performs SAML logout action.
func (c *Client) LogoutRaw(ctx context.Context) (*http.Response, error) {
	path := "/logout"

	return c.httpClient.Get(ctx, path, nil)
}

// Destroys user's session. In case of the SAML additionally performs SAML logout action.
func (c *Client) Logout(ctx context.Context) (*client.Response, error) {
	httpResp, err := c.LogoutRaw(ctx)
	if err != nil {
		return nil, err
	}
	defer httpResp.Body.Close()

	resp := &client.Response{Response: httpResp}

	return resp, nil
}

func (c *Client) OauthSigninRaw(ctx context.Context, provider string) (*http.Response, error) {
	path := "/iam/signin/{provider}"
	path = strings.ReplaceAll(path, "{provider}", url.PathEscape(provider))

	return c.httpClient.Get(ctx, path, nil)
}

func (c *Client) OauthSignin(ctx context.Context, provider string) (*client.Response, error) {
	httpResp, err := c.OauthSigninRaw(ctx, provider)
	if err != nil {
		return nil, err
	}
	defer httpResp.Body.Close()

	resp := &client.Response{Response: httpResp}

	return resp, nil
}

func (c *Client) OauthSignupRaw(ctx context.Context, provider string) (*http.Response, error) {
	path := "/iam/signup/{provider}"
	path = strings.ReplaceAll(path, "{provider}", url.PathEscape(provider))

	return c.httpClient.Get(ctx, path, nil)
}

func (c *Client) OauthSignup(ctx context.Context, provider string) (*client.Response, error) {
	httpResp, err := c.OauthSignupRaw(ctx, provider)
	if err != nil {
		return nil, err
	}
	defer httpResp.Body.Close()

	resp := &client.Response{Response: httpResp}

	return resp, nil
}

// Checks the connection to the API server
func (c *Client) PingRaw(ctx context.Context) (*http.Response, error) {
	path := "/ping"

	return c.httpClient.Get(ctx, path, nil)
}

// Checks the connection to the API server
func (c *Client) Ping(ctx context.Context) (string, *client.Response, error) {
	httpResp, err := c.PingRaw(ctx)
	if err != nil {
		return "", nil, err
	}
	defer httpResp.Body.Close()

	resp := &client.Response{Response: httpResp}

	bodyBytes, err := io.ReadAll(httpResp.Body)
	if err != nil {
		return "", resp, fmt.Errorf("failed to read response body: %w", err)
	}
	return string(bodyBytes), resp, nil
}
