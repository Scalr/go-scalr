// Code generated by scalr-gen. DO NOT EDIT.

package schemas

import (
	"encoding/json"
	"time"

	"github.com/scalr/go-scalr/v2/scalr/value"
)

// Response version - used when unmarshalling from API responses
// Represents a reusable hook in the Scalr Hooks Registry.
type Hook struct {
	ID            string            `json:"id"`
	Type          string            `json:"type"`
	Attributes    HookAttributes    `json:"attributes"`
	Relationships HookRelationships `json:"relationships"`
}

// GetID returns the resource ID (implements client.ResourceLike)
func (r Hook) GetID() string {
	return r.ID
}

// GetResourceType returns the JSON:API resource type (implements client.ResourceLike)
func (r Hook) GetResourceType() string {
	if r.Type != "" {
		return r.Type
	}
	return "hooks"
}

// HookAttributes holds the attributes for Hook (response)
type HookAttributes struct {
	// Brief description of the hook's purpose.
	Description string `json:"description"`
	// This field contains the error description, when this hook's status is `errored`.
	ErrorMessage string `json:"error-message"`
	// ID of the blob where hook source code is stored.
	HookBlobId string `json:"hook-blob-id"`
	// The interpreter used to execute the hook script. Examples: - `bash` - for shell scripts - `python` - for Python scripts - `node` - for JavaScript scripts **Important**: The interpreter specified here must be available in the execution environment. Make sure that the necessary dependencies are installed on the system where the hook will run. Scalr does not automatically install any runtime dependencies. This interpreter will be combined with the `scriptfile_path` to form the complete command to run the hook.
	Interpreter string `json:"interpreter"`
	// Unique name for the hook.
	Name string `json:"name"`
	// The path to the script file in the repository. This path is relative to the root of the repository. Examples: - `script.sh` - a script in the root directory - `scripts/hook.py` - a script in the scripts subdirectory - `/absolute/path.sh` - leading slash is automatically removed When the hook executes, the script runs in the Terraform workspace directory, not in the hook's directory. To access files within the hook directory, use the `SCALR_HOOK_DIR` environment variable: ```bash # Example: Read a config file from the hook directory cat "$SCALR_HOOK_DIR/config.json" # Example: Execute another script from the hook directory bash "$SCALR_HOOK_DIR/helpers/cleanup.sh" ``` The `interpreter` attribute specifies the command used to execute this script.
	ScriptfilePath string `json:"scriptfile-path"`
	// The status of the hook.
	Status string `json:"status"`
	// Timestamp of the last update.
	UpdatedAt time.Time `json:"updated-at"`
	// A reference to the VCS repository for the hook.
	VcsRepo HookVcsRepo `json:"vcs-repo"`
}

// HookRelationships holds the relationships for Hook (response)
type HookRelationships struct {
	// The account this hook belongs to.
	Account *Account `json:"account"`
	// The list of environments this hook is associated with.
	Environments []*Environment `json:"environments"`
	// The readme for the hook.
	Readme *HookReadme `json:"readme"`
	// The user who last updated the hook.
	UpdatedBy *User `json:"updated-by"`
	// The VCS provider associated with the hook.
	VcsProvider *VcsProvider `json:"vcs-provider"`
	// The Git commit information when the hook was fetched from VCS.
	VcsRevision *VcsRevision `json:"vcs-revision"`
}

// UnmarshalJSON implements custom unmarshalling for relationships
func (r *HookRelationships) UnmarshalJSON(data []byte) error {
	// Parse into temporary structure that matches JSON:API format
	var temp map[string]json.RawMessage
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}

	if raw, ok := temp["account"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Account = &Account{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["environments"]; ok {
		// To-many relationship
		var rel struct {
			Data []struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Environments = make([]*Environment, len(rel.Data))
			for i, d := range rel.Data {
				r.Environments[i] = &Environment{
					ID:   d.ID,
					Type: d.Type,
				}
			}
		}
	}
	if raw, ok := temp["readme"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Readme = &HookReadme{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["updated-by"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.UpdatedBy = &User{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["vcs-provider"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.VcsProvider = &VcsProvider{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["vcs-revision"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.VcsRevision = &VcsRevision{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	return nil
}

// PopulateIncludes merges included resources into the relationships
func (r *HookRelationships) PopulateIncludes(included []map[string]interface{}) {
	if r == nil || len(included) == 0 {
		return
	}

	// Build a map of included resources by type+id for fast lookup
	includedMap := make(map[string]map[string]interface{})
	for _, inc := range included {
		if id, ok := inc["id"].(string); ok {
			if typ, ok := inc["type"].(string); ok {
				key := typ + ":" + id
				includedMap[key] = inc
			}
		}
	}

	// Populate to-one relationship: Account
	if r.Account != nil && r.Account.ID != "" {
		key := r.Account.Type + ":" + r.Account.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full Account
			if err := json.Unmarshal(data, &full); err == nil {
				r.Account = &full
			}
		}
	}
	// Populate to-many relationship: Environments
	if r.Environments != nil {
		for i, resource := range r.Environments {
			if resource != nil && resource.ID != "" {
				key := resource.Type + ":" + resource.ID
				if fullResource, ok := includedMap[key]; ok {
					// Unmarshal the full resource
					data, _ := json.Marshal(fullResource)
					var full Environment
					if err := json.Unmarshal(data, &full); err == nil {
						r.Environments[i] = &full
					}
				}
			}
		}
	}
	// Populate to-one relationship: Readme
	if r.Readme != nil && r.Readme.ID != "" {
		key := r.Readme.Type + ":" + r.Readme.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full HookReadme
			if err := json.Unmarshal(data, &full); err == nil {
				r.Readme = &full
			}
		}
	}
	// Populate to-one relationship: UpdatedBy
	if r.UpdatedBy != nil && r.UpdatedBy.ID != "" {
		key := r.UpdatedBy.Type + ":" + r.UpdatedBy.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full User
			if err := json.Unmarshal(data, &full); err == nil {
				r.UpdatedBy = &full
			}
		}
	}
	// Populate to-one relationship: VcsProvider
	if r.VcsProvider != nil && r.VcsProvider.ID != "" {
		key := r.VcsProvider.Type + ":" + r.VcsProvider.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full VcsProvider
			if err := json.Unmarshal(data, &full); err == nil {
				r.VcsProvider = &full
			}
		}
	}
	// Populate to-one relationship: VcsRevision
	if r.VcsRevision != nil && r.VcsRevision.ID != "" {
		key := r.VcsRevision.Type + ":" + r.VcsRevision.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full VcsRevision
			if err := json.Unmarshal(data, &full); err == nil {
				r.VcsRevision = &full
			}
		}
	}
}

// Request version - used when marshalling for API requests
// Represents a reusable hook in the Scalr Hooks Registry. (for requests)
type HookRequest struct {
	ID            string                   `json:"id,omitempty"`
	Type          string                   `json:"type,omitempty"`
	Attributes    HookAttributesRequest    `json:"attributes,omitempty"`
	Relationships HookRelationshipsRequest `json:"relationships,omitempty"`
}

// MarshalJSON automatically sets the Type field during marshalling
func (r HookRequest) MarshalJSON() ([]byte, error) {
	type Alias HookRequest
	if r.Type == "" {
		r.Type = "hooks"
	}
	return json.Marshal((Alias)(r))
}

// GetID returns the resource ID (implements client.ResourceLike)
func (r HookRequest) GetID() string {
	return r.ID
}

// GetResourceType returns the JSON:API resource type (implements client.ResourceLike)
func (r HookRequest) GetResourceType() string {
	return "hooks"
}

// HookAttributesRequest holds the attributes for Hook (request)
type HookAttributesRequest struct {
	// Brief description of the hook's purpose.
	Description *value.Value[string] `json:"description,omitempty"`
	// The interpreter used to execute the hook script. Examples: - `bash` - for shell scripts - `python` - for Python scripts - `node` - for JavaScript scripts **Important**: The interpreter specified here must be available in the execution environment. Make sure that the necessary dependencies are installed on the system where the hook will run. Scalr does not automatically install any runtime dependencies. This interpreter will be combined with the `scriptfile_path` to form the complete command to run the hook.
	Interpreter *value.Value[string] `json:"interpreter,omitempty"`
	// Unique name for the hook.
	Name *value.Value[string] `json:"name,omitempty"`
	// The path to the script file in the repository. This path is relative to the root of the repository. Examples: - `script.sh` - a script in the root directory - `scripts/hook.py` - a script in the scripts subdirectory - `/absolute/path.sh` - leading slash is automatically removed When the hook executes, the script runs in the Terraform workspace directory, not in the hook's directory. To access files within the hook directory, use the `SCALR_HOOK_DIR` environment variable: ```bash # Example: Read a config file from the hook directory cat "$SCALR_HOOK_DIR/config.json" # Example: Execute another script from the hook directory bash "$SCALR_HOOK_DIR/helpers/cleanup.sh" ``` The `interpreter` attribute specifies the command used to execute this script.
	ScriptfilePath *value.Value[string] `json:"scriptfile-path,omitempty"`
	// A reference to the VCS repository for the hook.
	VcsRepo *value.Value[HookVcsRepoRequest] `json:"vcs-repo,omitempty"`
}

// HookRelationshipsRequest holds the relationships for Hook (request)
type HookRelationshipsRequest struct {
	// The VCS provider associated with the hook.
	VcsProvider *value.Value[VcsProvider] `json:"vcs-provider,omitempty"`
}

// A reference to the VCS repository for the hook.
type HookVcsRepo struct {
	// Branch of a repository the hook is associated with. If omitted, the repository default branch will be used.
	Branch string `json:"branch"`
	// A reference to the VCS repository. For GitHub, GitHub Enterprise and GitLab the format is `<org>/<repo>`. For Azure DevOps Services the format is `<org>/<project>/<repo>`.
	Identifier string `json:"identifier"`
}

// A reference to the VCS repository for the hook. (for requests)
type HookVcsRepoRequest struct {
	// Branch of a repository the hook is associated with. If omitted, the repository default branch will be used.
	Branch *value.Value[string] `json:"branch,omitempty"`
	// A reference to the VCS repository. For GitHub, GitHub Enterprise and GitLab the format is `<org>/<repo>`. For Azure DevOps Services the format is `<org>/<project>/<repo>`.
	Identifier *value.Value[string] `json:"identifier,omitempty"`
}
