// Code generated by scalr-gen. DO NOT EDIT.

package schemas

import (
	"encoding/json"
	"time"

	"github.com/scalr/go-scalr/v2/scalr/value"
)

// Response version - used when unmarshalling from API responses
// A Run provides details of an entire run operation potentially comprising `plan`, `cost-estimation`, `policy-check` and `apply`.
type Run struct {
	ID            string           `json:"id"`
	Type          string           `json:"type"`
	Attributes    RunAttributes    `json:"attributes"`
	Relationships RunRelationships `json:"relationships"`
}

// GetID returns the resource ID (implements client.ResourceLike)
func (r Run) GetID() string {
	return r.ID
}

// GetResourceType returns the JSON:API resource type (implements client.ResourceLike)
func (r Run) GetResourceType() string {
	if r.Type != "" {
		return r.Type
	}
	return "runs"
}

// RunAttributes holds the attributes for Run (response)
type RunAttributes struct {
	// The UTC datetime at which the Apply should be queued.
	ApplyAt time.Time `json:"apply-at"`
	// Indicates whether `terraform apply` should automatically run when terraform plan ends without error. Defaults to the current Auto Apply setting in the workspace. Auto-apply will be disallowed as a safety restriction if the workspace's current state version originates from an open Pull Request and the branch of this Pull Request is different from the branch of the run's configuration version. This prevents automatic applies when the current state is potentially based on unmerged code.
	AutoApply bool `json:"auto-apply"`
	// The resource creation timestamp.
	CreatedAt time.Time `json:"created-at"`
	// Contains error message, when the run has finished in `errored` status.
	ErrorMessage string `json:"error-message"`
	// Specifies whether the plan has proposed resource changes.
	HasChanges bool `json:"has-changes"`
	// The IaC platform for the run.
	IacPlatform string `json:"iac-platform"`
	// Terraform input variables that were passed into the workspace.
	Inputs []map[string]interface{} `json:"inputs"`
	// Indicates if this run is a destroy that will destroy all provisioned infrastructure in the current state.
	IsDestroy bool `json:"is-destroy"`
	IsDry     bool `json:"is-dry"`
	// Specifies the explanation message to associate with the run.
	Message     string                 `json:"message"`
	Permissions map[string]interface{} `json:"permissions"`
	// The UTC datetime at which the Plan should be queued.
	PlanAt          time.Time `json:"plan-at"`
	PositionInQueue int       `json:"position-in-queue"`
	// Specifies whether or not to refresh the state before a plan.
	Refresh bool `json:"refresh"`
	// Specifies whether this run should use the refresh-only plan mode.
	RefreshOnly bool `json:"refresh-only"`
	// Specifies an optional list of resource addresses to force replacement of a particular resource. If the plan would've normally produced an update or no-op action for this instance, Terraform will plan to replace it instead.
	ReplaceAddrs []string `json:"replace-addrs"`
	// The origin of the run.
	Source interface{} `json:"source"`
	// The Run's current status. Initial status: * `pending` - The initial status of a run once it has been created. Scalr processes each workspace's runs in the order they were queued, and a run remains pending until every run before it has completed. The exception are Runs having `is-dry: true`. Such runs don't modify a workspace's state, and could run in a parallel until the account's runs quota limit. Plan stage: * `plan_queued` - The plan is queued and waiting for capacity/and or quota to be available. * `planning` - Scalr is currently running `terraform plan`. * `planned` - `terraform plan` has finished. If the run's workspace has `auto-apply: false`, Scalr pauses the run in this state, awaiting confirmation. * `confirmed` - Run has been confirmed to apply. Cost estimate stage (optional): * `cost_estimating` - Scalr is currently calculating the cost estimate for the plan. * `cost_estimated` - The cost estimation stage has finished. Policy check stage (optional): * `policy_checking` - Scalr is currently checking the plan against the environment's policies. * `policy_checked` - The policy check succeeded, and Policy Engine will allow an apply to proceed. Scalr sometimes pauses in this state, depending on workspace settings. * `policy_override` - The policy check finished, but at least one `soft-mandatory` policy failed, so an apply cannot proceed without approval from a user having `policy-checks:override` permission. The run pauses in this state. Apply stage: * `apply_queued` - The apply is queued and waiting for capacity/and or quota to be available. * `applying` - Scalr is currently running `terraform apply`. * `applied` - Scalr has successfully finished applying. Ending statuses: * `planned_and_finished` - Dry run's pipeline of Plan -> CostEstimate -> PolicyCheck stages have finished. This is the final state for dry run. * `errored` - The run has finished with an error. The attribute `error-message` has the details. * `discarded` - A user chose not to continue this run from a confirmation state * `canceled` - A user interrupted the run from any active stage.
	Status string `json:"status"`
	// Timestamps of transition to prior and current statuses.
	StatusTimestamps map[string]interface{} `json:"status-timestamps"`
	// If non-empty, requests that Terraform should create a plan including actions only for the given objects (specified using resource address syntax) and the objects they depend on.
	TargetAddrs []string `json:"target-addrs"`
	// Run scope variables.
	Variables []map[string]interface{} `json:"variables"`
}

// RunRelationships holds the relationships for Run (response)
type RunRelationships struct {
	// Terraform apply phase.
	Apply *Apply `json:"apply"`
	// The Run's configuration version.
	ConfigurationVersion *ConfigurationVersion `json:"configuration-version"`
	// Cost estimation phase.
	CostEstimate *CostEstimate `json:"cost-estimate"`
	// User that has triggered the run.
	CreatedBy *User `json:"created-by"`
	// Upstream Run that has triggered this run.
	CreatedByRun *Run `json:"created-by-run"`
	// The environment this run Run belongs to.
	Environment *Environment `json:"environment"`
	// Terraform plan phase.
	Plan *Plan `json:"plan"`
	// Policy check phase.
	PolicyChecks []*PolicyCheck `json:"policy-checks"`
	// The run's state versions.
	StateVersions []*StateVersion `json:"state-versions"`
	// Date/Time of transition to each status that has occurred.
	StatusTransitions []*StatusTransition `json:"status-transitions"`
	Tags              []*Tag              `json:"tags"`
	// Relation to the Git commit information, when the run's `configuration-version` source is `vcs`
	VcsRevision *VcsRevision `json:"vcs-revision"`
	// The workspace this Run belongs to.
	Workspace *Workspace `json:"workspace"`
}

// UnmarshalJSON implements custom unmarshalling for relationships
func (r *RunRelationships) UnmarshalJSON(data []byte) error {
	// Parse into temporary structure that matches JSON:API format
	var temp map[string]json.RawMessage
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}

	if raw, ok := temp["apply"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Apply = &Apply{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["configuration-version"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.ConfigurationVersion = &ConfigurationVersion{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["cost-estimate"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.CostEstimate = &CostEstimate{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["created-by"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.CreatedBy = &User{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["created-by-run"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.CreatedByRun = &Run{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["environment"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Environment = &Environment{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["plan"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Plan = &Plan{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["policy-checks"]; ok {
		// To-many relationship
		var rel struct {
			Data []struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.PolicyChecks = make([]*PolicyCheck, len(rel.Data))
			for i, d := range rel.Data {
				r.PolicyChecks[i] = &PolicyCheck{
					ID:   d.ID,
					Type: d.Type,
				}
			}
		}
	}
	if raw, ok := temp["state-versions"]; ok {
		// To-many relationship
		var rel struct {
			Data []struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.StateVersions = make([]*StateVersion, len(rel.Data))
			for i, d := range rel.Data {
				r.StateVersions[i] = &StateVersion{
					ID:   d.ID,
					Type: d.Type,
				}
			}
		}
	}
	if raw, ok := temp["status-transitions"]; ok {
		// To-many relationship
		var rel struct {
			Data []struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.StatusTransitions = make([]*StatusTransition, len(rel.Data))
			for i, d := range rel.Data {
				r.StatusTransitions[i] = &StatusTransition{
					ID:   d.ID,
					Type: d.Type,
				}
			}
		}
	}
	if raw, ok := temp["tags"]; ok {
		// To-many relationship
		var rel struct {
			Data []struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Tags = make([]*Tag, len(rel.Data))
			for i, d := range rel.Data {
				r.Tags[i] = &Tag{
					ID:   d.ID,
					Type: d.Type,
				}
			}
		}
	}
	if raw, ok := temp["vcs-revision"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.VcsRevision = &VcsRevision{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["workspace"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Workspace = &Workspace{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	return nil
}

// PopulateIncludes merges included resources into the relationships
func (r *RunRelationships) PopulateIncludes(included []map[string]interface{}) {
	if r == nil || len(included) == 0 {
		return
	}

	// Build a map of included resources by type+id for fast lookup
	includedMap := make(map[string]map[string]interface{})
	for _, inc := range included {
		if id, ok := inc["id"].(string); ok {
			if typ, ok := inc["type"].(string); ok {
				key := typ + ":" + id
				includedMap[key] = inc
			}
		}
	}

	// Populate to-one relationship: Apply
	if r.Apply != nil && r.Apply.ID != "" {
		key := r.Apply.Type + ":" + r.Apply.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full Apply
			if err := json.Unmarshal(data, &full); err == nil {
				r.Apply = &full
			}
		}
	}
	// Populate to-one relationship: ConfigurationVersion
	if r.ConfigurationVersion != nil && r.ConfigurationVersion.ID != "" {
		key := r.ConfigurationVersion.Type + ":" + r.ConfigurationVersion.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full ConfigurationVersion
			if err := json.Unmarshal(data, &full); err == nil {
				r.ConfigurationVersion = &full
			}
		}
	}
	// Populate to-one relationship: CostEstimate
	if r.CostEstimate != nil && r.CostEstimate.ID != "" {
		key := r.CostEstimate.Type + ":" + r.CostEstimate.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full CostEstimate
			if err := json.Unmarshal(data, &full); err == nil {
				r.CostEstimate = &full
			}
		}
	}
	// Populate to-one relationship: CreatedBy
	if r.CreatedBy != nil && r.CreatedBy.ID != "" {
		key := r.CreatedBy.Type + ":" + r.CreatedBy.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full User
			if err := json.Unmarshal(data, &full); err == nil {
				r.CreatedBy = &full
			}
		}
	}
	// Populate to-one relationship: CreatedByRun
	if r.CreatedByRun != nil && r.CreatedByRun.ID != "" {
		key := r.CreatedByRun.Type + ":" + r.CreatedByRun.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full Run
			if err := json.Unmarshal(data, &full); err == nil {
				r.CreatedByRun = &full
			}
		}
	}
	// Populate to-one relationship: Environment
	if r.Environment != nil && r.Environment.ID != "" {
		key := r.Environment.Type + ":" + r.Environment.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full Environment
			if err := json.Unmarshal(data, &full); err == nil {
				r.Environment = &full
			}
		}
	}
	// Populate to-one relationship: Plan
	if r.Plan != nil && r.Plan.ID != "" {
		key := r.Plan.Type + ":" + r.Plan.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full Plan
			if err := json.Unmarshal(data, &full); err == nil {
				r.Plan = &full
			}
		}
	}
	// Populate to-many relationship: PolicyChecks
	if r.PolicyChecks != nil {
		for i, resource := range r.PolicyChecks {
			if resource != nil && resource.ID != "" {
				key := resource.Type + ":" + resource.ID
				if fullResource, ok := includedMap[key]; ok {
					// Unmarshal the full resource
					data, _ := json.Marshal(fullResource)
					var full PolicyCheck
					if err := json.Unmarshal(data, &full); err == nil {
						r.PolicyChecks[i] = &full
					}
				}
			}
		}
	}
	// Populate to-many relationship: StateVersions
	if r.StateVersions != nil {
		for i, resource := range r.StateVersions {
			if resource != nil && resource.ID != "" {
				key := resource.Type + ":" + resource.ID
				if fullResource, ok := includedMap[key]; ok {
					// Unmarshal the full resource
					data, _ := json.Marshal(fullResource)
					var full StateVersion
					if err := json.Unmarshal(data, &full); err == nil {
						r.StateVersions[i] = &full
					}
				}
			}
		}
	}
	// Populate to-many relationship: StatusTransitions
	if r.StatusTransitions != nil {
		for i, resource := range r.StatusTransitions {
			if resource != nil && resource.ID != "" {
				key := resource.Type + ":" + resource.ID
				if fullResource, ok := includedMap[key]; ok {
					// Unmarshal the full resource
					data, _ := json.Marshal(fullResource)
					var full StatusTransition
					if err := json.Unmarshal(data, &full); err == nil {
						r.StatusTransitions[i] = &full
					}
				}
			}
		}
	}
	// Populate to-many relationship: Tags
	if r.Tags != nil {
		for i, resource := range r.Tags {
			if resource != nil && resource.ID != "" {
				key := resource.Type + ":" + resource.ID
				if fullResource, ok := includedMap[key]; ok {
					// Unmarshal the full resource
					data, _ := json.Marshal(fullResource)
					var full Tag
					if err := json.Unmarshal(data, &full); err == nil {
						r.Tags[i] = &full
					}
				}
			}
		}
	}
	// Populate to-one relationship: VcsRevision
	if r.VcsRevision != nil && r.VcsRevision.ID != "" {
		key := r.VcsRevision.Type + ":" + r.VcsRevision.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full VcsRevision
			if err := json.Unmarshal(data, &full); err == nil {
				r.VcsRevision = &full
			}
		}
	}
	// Populate to-one relationship: Workspace
	if r.Workspace != nil && r.Workspace.ID != "" {
		key := r.Workspace.Type + ":" + r.Workspace.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full Workspace
			if err := json.Unmarshal(data, &full); err == nil {
				r.Workspace = &full
			}
		}
	}
}

// Request version - used when marshalling for API requests
// A Run provides details of an entire run operation potentially comprising `plan`, `cost-estimation`, `policy-check` and `apply`. (for requests)
type RunRequest struct {
	ID            string                  `json:"id,omitempty"`
	Type          string                  `json:"type,omitempty"`
	Attributes    RunAttributesRequest    `json:"attributes,omitempty"`
	Relationships RunRelationshipsRequest `json:"relationships,omitempty"`
}

// MarshalJSON automatically sets the Type field during marshalling
func (r RunRequest) MarshalJSON() ([]byte, error) {
	type Alias RunRequest
	if r.Type == "" {
		r.Type = "runs"
	}
	return json.Marshal((Alias)(r))
}

// GetID returns the resource ID (implements client.ResourceLike)
func (r RunRequest) GetID() string {
	return r.ID
}

// GetResourceType returns the JSON:API resource type (implements client.ResourceLike)
func (r RunRequest) GetResourceType() string {
	return "runs"
}

// RunAttributesRequest holds the attributes for Run (request)
type RunAttributesRequest struct {
	// Indicates whether `terraform apply` should automatically run when terraform plan ends without error. Defaults to the current Auto Apply setting in the workspace. Auto-apply will be disallowed as a safety restriction if the workspace's current state version originates from an open Pull Request and the branch of this Pull Request is different from the branch of the run's configuration version. This prevents automatic applies when the current state is potentially based on unmerged code.
	AutoApply *value.Value[bool] `json:"auto-apply,omitempty"`
	// Terraform input variables that were passed into the workspace.
	Inputs *value.Value[[]map[string]interface{}] `json:"inputs,omitempty"`
	// Indicates if this run is a destroy that will destroy all provisioned infrastructure in the current state.
	IsDestroy *value.Value[bool] `json:"is-destroy,omitempty"`
	IsDry     *value.Value[bool] `json:"is-dry,omitempty"`
	// Specifies the explanation message to associate with the run.
	Message *value.Value[string] `json:"message,omitempty"`
	// The UTC datetime at which the Plan should be queued.
	PlanAt *value.Value[time.Time] `json:"plan-at,omitempty"`
	// Specifies whether or not to refresh the state before a plan.
	Refresh *value.Value[bool] `json:"refresh,omitempty"`
	// Specifies whether this run should use the refresh-only plan mode.
	RefreshOnly *value.Value[bool] `json:"refresh-only,omitempty"`
	// Specifies an optional list of resource addresses to force replacement of a particular resource. If the plan would've normally produced an update or no-op action for this instance, Terraform will plan to replace it instead.
	ReplaceAddrs *value.Value[[]string] `json:"replace-addrs,omitempty"`
	// The origin of the run.
	Source *value.Value[interface{}] `json:"source,omitempty"`
	// If non-empty, requests that Terraform should create a plan including actions only for the given objects (specified using resource address syntax) and the objects they depend on.
	TargetAddrs *value.Value[[]string] `json:"target-addrs,omitempty"`
	// Run scope variables.
	Variables *value.Value[[]map[string]interface{}] `json:"variables,omitempty"`
}

// RunRelationshipsRequest holds the relationships for Run (request)
type RunRelationshipsRequest struct {
	// The Run's configuration version.
	ConfigurationVersion *value.Value[ConfigurationVersion] `json:"configuration-version,omitempty"`
	// Upstream Run that has triggered this run.
	CreatedByRun *value.Value[Run] `json:"created-by-run,omitempty"`
	// The workspace this Run belongs to.
	Workspace *value.Value[Workspace] `json:"workspace,omitempty"`
}
