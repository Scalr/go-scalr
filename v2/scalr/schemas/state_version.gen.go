// Code generated by scalr-gen. DO NOT EDIT.

package schemas

import (
	"encoding/json"
	"time"

	"github.com/scalr/go-scalr/v2/scalr/value"
)

// Response version - used when unmarshalling from API responses
// A State version is the version of a state file associated with a workspace.
type StateVersion struct {
	ID            string                    `json:"id"`
	Type          string                    `json:"type"`
	Attributes    StateVersionAttributes    `json:"attributes"`
	Relationships StateVersionRelationships `json:"relationships"`
}

// GetID returns the resource ID (implements client.ResourceLike)
func (r StateVersion) GetID() string {
	return r.ID
}

// GetResourceType returns the JSON:API resource type (implements client.ResourceLike)
func (r StateVersion) GetResourceType() string {
	if r.Type != "" {
		return r.Type
	}
	return "state-versions"
}

// StateVersionAttributes holds the attributes for StateVersion (response)
type StateVersionAttributes struct {
	// The resource creation timestamp.
	CreatedAt time.Time `json:"created-at"`
	Force     bool      `json:"force"`
	// Lineage of the state version. Should match the lineage extracted from the `terraform.tfstate`.
	Lineage *string `json:"lineage"`
	// The MD5 hash of the terraform.tfstate.
	Md5 string `json:"md5"`
	// The list of modules.
	Modules map[string]interface{} `json:"modules"`
	// The list of output values.
	Outputs *[]map[string]interface{} `json:"outputs"`
	// The list of providers.
	Providers map[string]interface{} `json:"providers"`
	// The list of resources.
	Resources []map[string]interface{} `json:"resources"`
	// The serial of the state version which must match the `serial` value from the `terraform.tfstate`.
	Serial int `json:"serial"`
	// Size of the `terraform.tfstate` in bytes.
	Size int `json:"size"`
	// Base64 encoded `terraform.tfstate`
	State *string `json:"state"`
}

// StateVersionRelationships holds the relationships for StateVersion (response)
type StateVersionRelationships struct {
	// Next state version for the workspace to which state version is associated.
	NextStateVersion *StateVersion `json:"next-state-version"`
	// Previous state version for the workspace to which state version is associated.
	PreviousStateVersion *StateVersion `json:"previous-state-version"`
	// The optional run associated with the state version.
	Run *Run `json:"run"`
	// The workspace, this state version belongs to.
	Workspace *Workspace `json:"workspace"`
}

// UnmarshalJSON implements custom unmarshalling for relationships
func (r *StateVersionRelationships) UnmarshalJSON(data []byte) error {
	// Parse into temporary structure that matches JSON:API format
	var temp map[string]json.RawMessage
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}

	if raw, ok := temp["next-state-version"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.NextStateVersion = &StateVersion{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["previous-state-version"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.PreviousStateVersion = &StateVersion{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["run"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Run = &Run{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["workspace"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Workspace = &Workspace{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	return nil
}

// PopulateIncludes merges included resources into the relationships
func (r *StateVersionRelationships) PopulateIncludes(included []map[string]interface{}) {
	if r == nil || len(included) == 0 {
		return
	}

	// Build a map of included resources by type+id for fast lookup
	includedMap := make(map[string]map[string]interface{})
	for _, inc := range included {
		if id, ok := inc["id"].(string); ok {
			if typ, ok := inc["type"].(string); ok {
				key := typ + ":" + id
				includedMap[key] = inc
			}
		}
	}

	// Populate to-one relationship: NextStateVersion
	if r.NextStateVersion != nil && r.NextStateVersion.ID != "" {
		key := r.NextStateVersion.Type + ":" + r.NextStateVersion.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full StateVersion
			if err := json.Unmarshal(data, &full); err == nil {
				r.NextStateVersion = &full
			}
		}
	}
	// Populate to-one relationship: PreviousStateVersion
	if r.PreviousStateVersion != nil && r.PreviousStateVersion.ID != "" {
		key := r.PreviousStateVersion.Type + ":" + r.PreviousStateVersion.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full StateVersion
			if err := json.Unmarshal(data, &full); err == nil {
				r.PreviousStateVersion = &full
			}
		}
	}
	// Populate to-one relationship: Run
	if r.Run != nil && r.Run.ID != "" {
		key := r.Run.Type + ":" + r.Run.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full Run
			if err := json.Unmarshal(data, &full); err == nil {
				r.Run = &full
			}
		}
	}
	// Populate to-one relationship: Workspace
	if r.Workspace != nil && r.Workspace.ID != "" {
		key := r.Workspace.Type + ":" + r.Workspace.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full Workspace
			if err := json.Unmarshal(data, &full); err == nil {
				r.Workspace = &full
			}
		}
	}
}

// Request version - used when marshalling for API requests
// A State version is the version of a state file associated with a workspace. (for requests)
type StateVersionRequest struct {
	ID            string                           `json:"id,omitempty"`
	Type          string                           `json:"type,omitempty"`
	Attributes    StateVersionAttributesRequest    `json:"attributes,omitempty"`
	Relationships StateVersionRelationshipsRequest `json:"relationships,omitempty"`
}

// MarshalJSON automatically sets the Type field during marshalling
func (r StateVersionRequest) MarshalJSON() ([]byte, error) {
	type Alias StateVersionRequest
	if r.Type == "" {
		r.Type = "state-versions"
	}
	return json.Marshal((Alias)(r))
}

// GetID returns the resource ID (implements client.ResourceLike)
func (r StateVersionRequest) GetID() string {
	return r.ID
}

// GetResourceType returns the JSON:API resource type (implements client.ResourceLike)
func (r StateVersionRequest) GetResourceType() string {
	return "state-versions"
}

// StateVersionAttributesRequest holds the attributes for StateVersion (request)
type StateVersionAttributesRequest struct {
	Force *value.Value[bool] `json:"force,omitempty"`
	// Lineage of the state version. Should match the lineage extracted from the `terraform.tfstate`.
	Lineage *value.Value[string] `json:"lineage,omitempty"`
	// The MD5 hash of the terraform.tfstate.
	Md5 *value.Value[string] `json:"md5,omitempty"`
	// The serial of the state version which must match the `serial` value from the `terraform.tfstate`.
	Serial *value.Value[int] `json:"serial,omitempty"`
	// Base64 encoded `terraform.tfstate`
	State *value.Value[string] `json:"state,omitempty"`
}

// StateVersionRelationshipsRequest holds the relationships for StateVersion (request)
type StateVersionRelationshipsRequest struct {
	// The optional run associated with the state version.
	Run *value.Value[Run] `json:"run,omitempty"`
	// The workspace, this state version belongs to.
	Workspace *value.Value[Workspace] `json:"workspace,omitempty"`
}
