// Code generated by scalr-gen. DO NOT EDIT.

package schemas

import (
	"encoding/json"
	"time"

	"github.com/scalr/go-scalr/v2/scalr/value"
)

// Response version - used when unmarshalling from API responses
// API Resource for the account.
type Account struct {
	ID            string               `json:"id"`
	Type          string               `json:"type"`
	Attributes    AccountAttributes    `json:"attributes"`
	Relationships AccountRelationships `json:"relationships"`
}

// GetID returns the resource ID (implements client.ResourceLike)
func (r Account) GetID() string {
	return r.ID
}

// GetResourceType returns the JSON:API resource type (implements client.ResourceLike)
func (r Account) GetResourceType() string {
	if r.Type != "" {
		return r.Type
	}
	return "accounts"
}

// AccountAttributes holds the attributes for Account (response)
type AccountAttributes struct {
	// The list of allowed IP networks for IP fencing
	AllowedIps         []string   `json:"allowed-ips"`
	CreatedAt          time.Time  `json:"created-at"`
	LastLoginAttemptAt *time.Time `json:"last-login-attempt-at"`
	LoginAttempts      *int       `json:"login-attempts"`
	// The name of the account
	Name string `json:"name"`
	// The list of account's quotas
	Quotas AccountQuotas `json:"quotas"`
	// If enabled, Scalr support staff will be able to access the account for troubleshooting purposes.
	SupportAccessEnabled bool `json:"support-access-enabled"`
}

// AccountRelationships holds the relationships for Account (response)
type AccountRelationships struct {
	// The billing plan of this account
	BillingPlan *BillingPlan `json:"billing-plan"`
	// The identity provider of this account
	IdentityProvider *IdentityProvider `json:"identity-provider"`
	// The user that owns this account
	Owner *User `json:"owner"`
}

// UnmarshalJSON implements custom unmarshalling for relationships
func (r *AccountRelationships) UnmarshalJSON(data []byte) error {
	// Parse into temporary structure that matches JSON:API format
	var temp map[string]json.RawMessage
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}

	if raw, ok := temp["billing-plan"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.BillingPlan = &BillingPlan{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["identity-provider"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.IdentityProvider = &IdentityProvider{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["owner"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Owner = &User{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	return nil
}

// PopulateIncludes merges included resources into the relationships
func (r *AccountRelationships) PopulateIncludes(included []map[string]interface{}) {
	if r == nil || len(included) == 0 {
		return
	}

	// Build a map of included resources by type+id for fast lookup
	includedMap := make(map[string]map[string]interface{})
	for _, inc := range included {
		if id, ok := inc["id"].(string); ok {
			if typ, ok := inc["type"].(string); ok {
				key := typ + ":" + id
				includedMap[key] = inc
			}
		}
	}

	// Populate to-one relationship: BillingPlan
	if r.BillingPlan != nil && r.BillingPlan.ID != "" {
		key := r.BillingPlan.Type + ":" + r.BillingPlan.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full BillingPlan
			if err := json.Unmarshal(data, &full); err == nil {
				r.BillingPlan = &full
			}
		}
	}
	// Populate to-one relationship: IdentityProvider
	if r.IdentityProvider != nil && r.IdentityProvider.ID != "" {
		key := r.IdentityProvider.Type + ":" + r.IdentityProvider.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full IdentityProvider
			if err := json.Unmarshal(data, &full); err == nil {
				r.IdentityProvider = &full
			}
		}
	}
	// Populate to-one relationship: Owner
	if r.Owner != nil && r.Owner.ID != "" {
		key := r.Owner.Type + ":" + r.Owner.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full User
			if err := json.Unmarshal(data, &full); err == nil {
				r.Owner = &full
			}
		}
	}
}

// Request version - used when marshalling for API requests
// API Resource for the account. (for requests)
type AccountRequest struct {
	ID            string                      `json:"id,omitempty"`
	Type          string                      `json:"type,omitempty"`
	Attributes    AccountAttributesRequest    `json:"attributes,omitempty"`
	Relationships AccountRelationshipsRequest `json:"relationships,omitempty"`
}

// MarshalJSON automatically sets the Type field during marshalling
func (r AccountRequest) MarshalJSON() ([]byte, error) {
	type Alias AccountRequest
	if r.Type == "" {
		r.Type = "accounts"
	}
	return json.Marshal((Alias)(r))
}

// GetID returns the resource ID (implements client.ResourceLike)
func (r AccountRequest) GetID() string {
	return r.ID
}

// GetResourceType returns the JSON:API resource type (implements client.ResourceLike)
func (r AccountRequest) GetResourceType() string {
	return "accounts"
}

// AccountAttributesRequest holds the attributes for Account (request)
type AccountAttributesRequest struct {
	// The list of allowed IP networks for IP fencing
	AllowedIps *value.Value[[]string] `json:"allowed-ips,omitempty"`
	// The name of the account
	Name *value.Value[string] `json:"name,omitempty"`
	// The list of account's quotas
	Quotas *value.Value[AccountQuotasRequest] `json:"quotas,omitempty"`
	// If enabled, Scalr support staff will be able to access the account for troubleshooting purposes.
	SupportAccessEnabled *value.Value[bool] `json:"support-access-enabled,omitempty"`
}

// AccountRelationshipsRequest holds the relationships for Account (request)
type AccountRelationshipsRequest struct {
	// The identity provider of this account
	IdentityProvider *value.Value[IdentityProvider] `json:"identity-provider,omitempty"`
	// The user that owns this account
	Owner *value.Value[User] `json:"owner,omitempty"`
}

// The list of account's quotas
type AccountQuotas struct {
	// Indicates if the agent relay is available for an account
	AgentRelayAvailable bool `json:"agent-relay-available"`
	// The maximal number of agents
	Agents int `json:"agents"`
	// Indicates if the before-after hooks are available for an account
	BeforeAfterHooksAvailable bool `json:"before-after-hooks-available"`
	// The maximal number of environments
	Environments int `json:"environments"`
	// The maximal number of concurrent runs
	MaxConcurrentRuns int `json:"max-concurrent-runs"`
	// Indicates if the policy group checks are available for an account
	PolicyGroupChecksAvailable bool `json:"policy-group-checks-available"`
	// The maximal number of policy groups
	PolicyGroups int `json:"policy-groups"`
	// The maximal number of registry modules
	RegistryModules int `json:"registry-modules"`
	// The maximal number of registry templates
	RegistryTemplates int `json:"registry-templates"`
	// The maximal number of run triggers
	RunTriggers int `json:"run-triggers"`
	// Indicates if the service accounts are available for an account
	ServiceAccountsAvailable bool `json:"service-accounts-available"`
	// Indicates if the SSO is available for an account
	SsoAvailable bool `json:"sso-available"`
	// The maximal number of users
	Users int `json:"users"`
	// The maximal number of VCS providers
	VcsProviders int `json:"vcs-providers"`
	// The maximal number of workspaces
	Workspaces int `json:"workspaces"`
}

// The list of account's quotas (for requests)
type AccountQuotasRequest struct {
	// Indicates if the agent relay is available for an account
	AgentRelayAvailable *value.Value[bool] `json:"agent-relay-available,omitempty"`
	// The maximal number of agents
	Agents *value.Value[int] `json:"agents,omitempty"`
	// Indicates if the before-after hooks are available for an account
	BeforeAfterHooksAvailable *value.Value[bool] `json:"before-after-hooks-available,omitempty"`
	// The maximal number of environments
	Environments *value.Value[int] `json:"environments,omitempty"`
	// The maximal number of concurrent runs
	MaxConcurrentRuns *value.Value[int] `json:"max-concurrent-runs,omitempty"`
	// Indicates if the policy group checks are available for an account
	PolicyGroupChecksAvailable *value.Value[bool] `json:"policy-group-checks-available,omitempty"`
	// The maximal number of policy groups
	PolicyGroups *value.Value[int] `json:"policy-groups,omitempty"`
	// The maximal number of registry modules
	RegistryModules *value.Value[int] `json:"registry-modules,omitempty"`
	// The maximal number of registry templates
	RegistryTemplates *value.Value[int] `json:"registry-templates,omitempty"`
	// The maximal number of run triggers
	RunTriggers *value.Value[int] `json:"run-triggers,omitempty"`
	// Indicates if the service accounts are available for an account
	ServiceAccountsAvailable *value.Value[bool] `json:"service-accounts-available,omitempty"`
	// Indicates if the SSO is available for an account
	SsoAvailable *value.Value[bool] `json:"sso-available,omitempty"`
	// The maximal number of users
	Users *value.Value[int] `json:"users,omitempty"`
	// The maximal number of VCS providers
	VcsProviders *value.Value[int] `json:"vcs-providers,omitempty"`
	// The maximal number of workspaces
	Workspaces *value.Value[int] `json:"workspaces,omitempty"`
}
