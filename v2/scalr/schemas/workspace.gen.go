// Code generated by scalr-gen. DO NOT EDIT.

package schemas

import (
	"encoding/json"
	"time"

	"github.com/scalr/go-scalr/v2/scalr/value"
)

// WorkspaceAutoDestroyDays represents the type for WorkspaceAutoDestroyDays
// How many days should the workspace exist.
type WorkspaceAutoDestroyDays int

// WorkspaceAutoDestroyDays constants
const (
	WorkspaceAutoDestroyDays1  WorkspaceAutoDestroyDays = 1
	WorkspaceAutoDestroyDays2  WorkspaceAutoDestroyDays = 2
	WorkspaceAutoDestroyDays7  WorkspaceAutoDestroyDays = 7
	WorkspaceAutoDestroyDays14 WorkspaceAutoDestroyDays = 14
)

// WorkspaceAutoQueueRuns represents the type for WorkspaceAutoQueueRuns
// Indicates if runs have to be queued automatically when a new configuration version is uploaded. `skip_first` - after the very first configuration version is uploaded into the workspace the run will not be triggered. But the following configurations will do. This is the default behavior. `on_create_only` - single run will be triggered only when the workspace is created and the first configuration version is uploaded. Subsequent configurations will not trigger runs. `always` - runs will be triggered automatically on every upload of the configuration version. `never` - configuration versions are uploaded into the workspace, but runs will not be triggered.
type WorkspaceAutoQueueRuns string

// WorkspaceAutoQueueRuns constants
const (
	WorkspaceAutoQueueRunsAlways       WorkspaceAutoQueueRuns = "always"
	WorkspaceAutoQueueRunsNever        WorkspaceAutoQueueRuns = "never"
	WorkspaceAutoQueueRunsSkipFirst    WorkspaceAutoQueueRuns = "skip_first"
	WorkspaceAutoQueueRunsOnCreateOnly WorkspaceAutoQueueRuns = "on_create_only"
)

// WorkspaceEnvironmentType represents the type for WorkspaceEnvironmentType
// The type of the Scalr Workspace environment.
type WorkspaceEnvironmentType string

// WorkspaceEnvironmentType constants
const (
	WorkspaceEnvironmentTypeProduction  WorkspaceEnvironmentType = "production"
	WorkspaceEnvironmentTypeStaging     WorkspaceEnvironmentType = "staging"
	WorkspaceEnvironmentTypeTesting     WorkspaceEnvironmentType = "testing"
	WorkspaceEnvironmentTypeDevelopment WorkspaceEnvironmentType = "development"
	WorkspaceEnvironmentTypeUnmapped    WorkspaceEnvironmentType = "unmapped"
)

// WorkspaceIacPlatform represents the type for WorkspaceIacPlatform
// The IaC platform of this workspace.
type WorkspaceIacPlatform string

// WorkspaceIacPlatform constants
const (
	WorkspaceIacPlatformTerraform WorkspaceIacPlatform = "terraform"
	WorkspaceIacPlatformOpentofu  WorkspaceIacPlatform = "opentofu"
)

// WorkspaceExecutionMode represents the type for WorkspaceExecutionMode
// Which execution mode to use. Valid values are `remote` and `local`. When set to `local`, the workspace will be used for state storage only.
type WorkspaceExecutionMode string

// WorkspaceExecutionMode constants
const (
	WorkspaceExecutionModeRemote WorkspaceExecutionMode = "remote"
	WorkspaceExecutionModeLocal  WorkspaceExecutionMode = "local"
)

// Response version - used when unmarshalling from API responses
// A Workspace is where Terraform runs are performed for a specific configuration, and where the resulting state file(s) are stored. Workspaces belong to environments and can have `variables` configured to provide inputs to the configuration, authenticate providers etc. The extra fields below are not available in response by default. Ask for them explicitly in the query parameter `fields[workspaces]`: * module
type Workspace struct {
	ID            string                 `json:"id"`
	Type          string                 `json:"type"`
	Attributes    WorkspaceAttributes    `json:"attributes"`
	Relationships WorkspaceRelationships `json:"relationships"`
}

// GetID returns the resource ID (implements client.ResourceLike)
func (r Workspace) GetID() string {
	return r.ID
}

// GetResourceType returns the JSON:API resource type (implements client.ResourceLike)
func (r Workspace) GetResourceType() string {
	if r.Type != "" {
		return r.Type
	}
	return "workspaces"
}

// WorkspaceAttributes holds the attributes for Workspace (response)
type WorkspaceAttributes struct {
	// Cron expression for scheduled runs. Time should be in UTC.
	ApplySchedule *string `json:"apply-schedule"`
	// Indicates whether `terraform apply` should automatically run when terraform plan ends without error. Default `false`.
	AutoApply bool `json:"auto-apply"`
	// How many days should the workspace exist.
	AutoDestroyDays *WorkspaceAutoDestroyDays `json:"auto-destroy-days"`
	// The status of scheduled destruction of the workspace.
	AutoDestroyStatus *string `json:"auto-destroy-status"`
	// When should the destruction of the workspace begin.
	AutoDestroyTime *time.Time `json:"auto-destroy-time"`
	// Indicates if runs have to be queued automatically when a new configuration version is uploaded. `skip_first` - after the very first configuration version is uploaded into the workspace the run will not be triggered. But the following configurations will do. This is the default behavior. `on_create_only` - single run will be triggered only when the workspace is created and the first configuration version is uploaded. Subsequent configurations will not trigger runs. `always` - runs will be triggered automatically on every upload of the configuration version. `never` - configuration versions are uploaded into the workspace, but runs will not be triggered.
	AutoQueueRuns WorkspaceAutoQueueRuns `json:"auto-queue-runs"`
	// The resource creation timestamp.
	CreatedAt time.Time `json:"created-at"`
	// The email of a user who toggled deletion protection.
	DeletionProtectionChangedByEmail *string `json:"deletion-protection-changed-by-email"`
	// Designates whether deletion protection is enabled.
	DeletionProtectionEnabled bool `json:"deletion-protection-enabled"`
	// Cron expression for scheduled destroy runs. Time should be in UTC.
	DestroySchedule *string `json:"destroy-schedule"`
	// The type of the Scalr Workspace environment.
	EnvironmentType WorkspaceEnvironmentType `json:"environment-type"`
	// Which execution mode to use. Valid values are `remote` and `local`. When set to `local`, the workspace will be used for state storage only.
	ExecutionMode WorkspaceExecutionMode `json:"execution-mode"`
	// Indicates whether `force run` should automatically apply to latest run. Default `false`.
	ForceLatestRun bool `json:"force-latest-run"`
	// Indicates whether the workspace's current state version contains terraform resources.
	HasResources bool            `json:"has-resources"`
	Hooks        *WorkspaceHooks `json:"hooks"`
	// The IaC platform of this workspace.
	IacPlatform WorkspaceIacPlatform `json:"iac-platform"`
	// The reason (if any) that the workspace has been locked.
	LockReason *string `json:"lock-reason"`
	// Indicates whether the workspace is locked for operations. The `lock-reason` attribute carries the explanation. This semaphore is acquired and released by terraform apply and can also manage it with Lock/Unlock Workspace. Default: `false`
	Locked bool `json:"locked"`
	// Workspace name which must be unique within the environment. Comprises letters, numbers, `-`, and `_` only.
	Name string `json:"name"`
	// The attribute `operations` is deprecated. Use `execution-mode` instead.
	Operations  bool                   `json:"operations"`
	Permissions map[string]interface{} `json:"permissions"`
	// Manages if Scalr exports the remote backend configuration and state storage for your infrastructure management. Disabling this feature will also prevent the ability to perform state locking, which ensures that concurrent operations do not conflict. Additionally, it will disable the capability to initiate CLI-driven runs through Scalr.
	RemoteBackend bool `json:"remote-backend"`
	// Specifies if the state is shared within the environment.
	RemoteStateSharing bool `json:"remote-state-sharing"`
	// The timeout for the Terraform Run operations (in minutes).
	RunOperationTimeout *int `json:"run-operation-timeout"`
	// The version of Terraform the workspace performs runs on. If omitted, the system default version is assigned.
	TerraformVersion string               `json:"terraform-version"`
	Terragrunt       *WorkspaceTerragrunt `json:"terragrunt"`
	// The resource last update timestamp.
	UpdatedAt *time.Time `json:"updated-at"`
	// The email of the last user, that updated this workspace.
	UpdatedByEmail *string `json:"updated-by-email"`
	// The list of Terraform variables files.
	VarFiles *[]string         `json:"var-files"`
	VcsRepo  *WorkspaceVcsRepo `json:"vcs-repo"`
	// A relative path where Terraform commands will execute in.
	WorkingDirectory *string `json:"working-directory"`
}

// WorkspaceRelationships holds the relationships for Workspace (response)
type WorkspaceRelationships struct {
	// The ID of the agent pool used to execute run stages. Overrides the default account-level and environment-level pools.
	AgentPool *AgentPool `json:"agent-pool"`
	// The latest uploaded configuration version.
	ConfigurationVersion *ConfigurationVersion `json:"configuration-version"`
	// The user, who has triggered the run.
	CreatedBy *User `json:"created-by"`
	// Currently executing Run.
	CurrentRun *Run `json:"current-run"`
	// The drift report for the workspace.
	DriftReport *DriftReport `json:"drift-report"`
	// The environment this workspace belongs to.
	Environment *Environment `json:"environment"`
	// The configuration version of the latest non-dry Run in this workspace.
	LatestConfigurationVersion *ConfigurationVersion `json:"latest-configuration-version"`
	// Latest finished Run.
	LatestRun   *Run  `json:"latest-run"`
	LockedBy    *User `json:"locked-by"`
	LockedByRun *Run  `json:"locked-by-run"`
	// The ID of the module.
	Module *Module `json:"module"`
	// The ID of the module version.
	ModuleVersion *ModuleVersion `json:"module-version"`
	// The readme for the workspace.
	ReadmeId *WorkspaceReadme `json:"readme-id"`
	// The SSH key used to this workspace.
	SshKey *SSHKey `json:"ssh-key"`
	Tags   []*Tag  `json:"tags"`
	// The last user, that updated this workspace.
	UpdatedBy *User `json:"updated-by"`
	// VCS provider of the Run's workspace
	VcsProvider *VcsProvider `json:"vcs-provider"`
}

// UnmarshalJSON implements custom unmarshalling for relationships
func (r *WorkspaceRelationships) UnmarshalJSON(data []byte) error {
	// Parse into temporary structure that matches JSON:API format
	var temp map[string]json.RawMessage
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}

	if raw, ok := temp["agent-pool"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.AgentPool = &AgentPool{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["configuration-version"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.ConfigurationVersion = &ConfigurationVersion{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["created-by"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.CreatedBy = &User{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["current-run"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.CurrentRun = &Run{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["drift-report"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.DriftReport = &DriftReport{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["environment"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Environment = &Environment{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["latest-configuration-version"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.LatestConfigurationVersion = &ConfigurationVersion{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["latest-run"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.LatestRun = &Run{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["locked-by"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.LockedBy = &User{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["locked-by-run"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.LockedByRun = &Run{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["module"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Module = &Module{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["module-version"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.ModuleVersion = &ModuleVersion{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["readme-id"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.ReadmeId = &WorkspaceReadme{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["ssh-key"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.SshKey = &SSHKey{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["tags"]; ok {
		// To-many relationship
		var rel struct {
			Data []struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Tags = make([]*Tag, len(rel.Data))
			for i, d := range rel.Data {
				r.Tags[i] = &Tag{
					ID:   d.ID,
					Type: d.Type,
				}
			}
		}
	}
	if raw, ok := temp["updated-by"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.UpdatedBy = &User{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["vcs-provider"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.VcsProvider = &VcsProvider{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	return nil
}

// PopulateIncludes merges included resources into the relationships
func (r *WorkspaceRelationships) PopulateIncludes(included []map[string]interface{}) {
	if r == nil || len(included) == 0 {
		return
	}

	// Build a map of included resources by type+id for fast lookup
	includedMap := make(map[string]map[string]interface{})
	for _, inc := range included {
		if id, ok := inc["id"].(string); ok {
			if typ, ok := inc["type"].(string); ok {
				key := typ + ":" + id
				includedMap[key] = inc
			}
		}
	}

	// Populate to-one relationship: AgentPool
	if r.AgentPool != nil && r.AgentPool.ID != "" {
		key := r.AgentPool.Type + ":" + r.AgentPool.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full AgentPool
			if err := json.Unmarshal(data, &full); err == nil {
				r.AgentPool = &full
			}
		}
	}
	// Populate to-one relationship: ConfigurationVersion
	if r.ConfigurationVersion != nil && r.ConfigurationVersion.ID != "" {
		key := r.ConfigurationVersion.Type + ":" + r.ConfigurationVersion.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full ConfigurationVersion
			if err := json.Unmarshal(data, &full); err == nil {
				r.ConfigurationVersion = &full
			}
		}
	}
	// Populate to-one relationship: CreatedBy
	if r.CreatedBy != nil && r.CreatedBy.ID != "" {
		key := r.CreatedBy.Type + ":" + r.CreatedBy.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full User
			if err := json.Unmarshal(data, &full); err == nil {
				r.CreatedBy = &full
			}
		}
	}
	// Populate to-one relationship: CurrentRun
	if r.CurrentRun != nil && r.CurrentRun.ID != "" {
		key := r.CurrentRun.Type + ":" + r.CurrentRun.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full Run
			if err := json.Unmarshal(data, &full); err == nil {
				r.CurrentRun = &full
			}
		}
	}
	// Populate to-one relationship: DriftReport
	if r.DriftReport != nil && r.DriftReport.ID != "" {
		key := r.DriftReport.Type + ":" + r.DriftReport.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full DriftReport
			if err := json.Unmarshal(data, &full); err == nil {
				r.DriftReport = &full
			}
		}
	}
	// Populate to-one relationship: Environment
	if r.Environment != nil && r.Environment.ID != "" {
		key := r.Environment.Type + ":" + r.Environment.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full Environment
			if err := json.Unmarshal(data, &full); err == nil {
				r.Environment = &full
			}
		}
	}
	// Populate to-one relationship: LatestConfigurationVersion
	if r.LatestConfigurationVersion != nil && r.LatestConfigurationVersion.ID != "" {
		key := r.LatestConfigurationVersion.Type + ":" + r.LatestConfigurationVersion.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full ConfigurationVersion
			if err := json.Unmarshal(data, &full); err == nil {
				r.LatestConfigurationVersion = &full
			}
		}
	}
	// Populate to-one relationship: LatestRun
	if r.LatestRun != nil && r.LatestRun.ID != "" {
		key := r.LatestRun.Type + ":" + r.LatestRun.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full Run
			if err := json.Unmarshal(data, &full); err == nil {
				r.LatestRun = &full
			}
		}
	}
	// Populate to-one relationship: LockedBy
	if r.LockedBy != nil && r.LockedBy.ID != "" {
		key := r.LockedBy.Type + ":" + r.LockedBy.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full User
			if err := json.Unmarshal(data, &full); err == nil {
				r.LockedBy = &full
			}
		}
	}
	// Populate to-one relationship: LockedByRun
	if r.LockedByRun != nil && r.LockedByRun.ID != "" {
		key := r.LockedByRun.Type + ":" + r.LockedByRun.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full Run
			if err := json.Unmarshal(data, &full); err == nil {
				r.LockedByRun = &full
			}
		}
	}
	// Populate to-one relationship: Module
	if r.Module != nil && r.Module.ID != "" {
		key := r.Module.Type + ":" + r.Module.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full Module
			if err := json.Unmarshal(data, &full); err == nil {
				r.Module = &full
			}
		}
	}
	// Populate to-one relationship: ModuleVersion
	if r.ModuleVersion != nil && r.ModuleVersion.ID != "" {
		key := r.ModuleVersion.Type + ":" + r.ModuleVersion.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full ModuleVersion
			if err := json.Unmarshal(data, &full); err == nil {
				r.ModuleVersion = &full
			}
		}
	}
	// Populate to-one relationship: ReadmeId
	if r.ReadmeId != nil && r.ReadmeId.ID != "" {
		key := r.ReadmeId.Type + ":" + r.ReadmeId.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full WorkspaceReadme
			if err := json.Unmarshal(data, &full); err == nil {
				r.ReadmeId = &full
			}
		}
	}
	// Populate to-one relationship: SshKey
	if r.SshKey != nil && r.SshKey.ID != "" {
		key := r.SshKey.Type + ":" + r.SshKey.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full SSHKey
			if err := json.Unmarshal(data, &full); err == nil {
				r.SshKey = &full
			}
		}
	}
	// Populate to-many relationship: Tags
	if r.Tags != nil {
		for i, resource := range r.Tags {
			if resource != nil && resource.ID != "" {
				key := resource.Type + ":" + resource.ID
				if fullResource, ok := includedMap[key]; ok {
					// Unmarshal the full resource
					data, _ := json.Marshal(fullResource)
					var full Tag
					if err := json.Unmarshal(data, &full); err == nil {
						r.Tags[i] = &full
					}
				}
			}
		}
	}
	// Populate to-one relationship: UpdatedBy
	if r.UpdatedBy != nil && r.UpdatedBy.ID != "" {
		key := r.UpdatedBy.Type + ":" + r.UpdatedBy.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full User
			if err := json.Unmarshal(data, &full); err == nil {
				r.UpdatedBy = &full
			}
		}
	}
	// Populate to-one relationship: VcsProvider
	if r.VcsProvider != nil && r.VcsProvider.ID != "" {
		key := r.VcsProvider.Type + ":" + r.VcsProvider.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full VcsProvider
			if err := json.Unmarshal(data, &full); err == nil {
				r.VcsProvider = &full
			}
		}
	}
}

// Request version - used when marshalling for API requests
// A Workspace is where Terraform runs are performed for a specific configuration, and where the resulting state file(s) are stored. Workspaces belong to environments and can have `variables` configured to provide inputs to the configuration, authenticate providers etc. The extra fields below are not available in response by default. Ask for them explicitly in the query parameter `fields[workspaces]`: * module (for requests)
type WorkspaceRequest struct {
	ID            string                        `json:"id,omitempty"`
	Type          string                        `json:"type,omitempty"`
	Attributes    WorkspaceAttributesRequest    `json:"attributes,omitempty"`
	Relationships WorkspaceRelationshipsRequest `json:"relationships,omitempty"`
}

// MarshalJSON automatically sets the Type field during marshalling
func (r WorkspaceRequest) MarshalJSON() ([]byte, error) {
	type Alias WorkspaceRequest
	if r.Type == "" {
		r.Type = "workspaces"
	}
	return json.Marshal((Alias)(r))
}

// GetID returns the resource ID (implements client.ResourceLike)
func (r WorkspaceRequest) GetID() string {
	return r.ID
}

// GetResourceType returns the JSON:API resource type (implements client.ResourceLike)
func (r WorkspaceRequest) GetResourceType() string {
	return "workspaces"
}

// WorkspaceAttributesRequest holds the attributes for Workspace (request)
type WorkspaceAttributesRequest struct {
	// Indicates whether `terraform apply` should automatically run when terraform plan ends without error. Default `false`.
	AutoApply *value.Value[bool] `json:"auto-apply,omitempty"`
	// How many days should the workspace exist.
	AutoDestroyDays *value.Value[WorkspaceAutoDestroyDays] `json:"auto-destroy-days,omitempty"`
	// Indicates if runs have to be queued automatically when a new configuration version is uploaded. `skip_first` - after the very first configuration version is uploaded into the workspace the run will not be triggered. But the following configurations will do. This is the default behavior. `on_create_only` - single run will be triggered only when the workspace is created and the first configuration version is uploaded. Subsequent configurations will not trigger runs. `always` - runs will be triggered automatically on every upload of the configuration version. `never` - configuration versions are uploaded into the workspace, but runs will not be triggered.
	AutoQueueRuns *value.Value[WorkspaceAutoQueueRuns] `json:"auto-queue-runs,omitempty"`
	// Designates whether deletion protection is enabled.
	DeletionProtectionEnabled *value.Value[bool] `json:"deletion-protection-enabled,omitempty"`
	// The type of the Scalr Workspace environment.
	EnvironmentType *value.Value[WorkspaceEnvironmentType] `json:"environment-type,omitempty"`
	// Which execution mode to use. Valid values are `remote` and `local`. When set to `local`, the workspace will be used for state storage only.
	ExecutionMode *value.Value[WorkspaceExecutionMode] `json:"execution-mode,omitempty"`
	// Indicates whether `force run` should automatically apply to latest run. Default `false`.
	ForceLatestRun *value.Value[bool]                  `json:"force-latest-run,omitempty"`
	Hooks          *value.Value[WorkspaceHooksRequest] `json:"hooks,omitempty"`
	// The IaC platform of this workspace.
	IacPlatform *value.Value[WorkspaceIacPlatform] `json:"iac-platform,omitempty"`
	// Workspace name which must be unique within the environment. Comprises letters, numbers, `-`, and `_` only.
	Name *value.Value[string] `json:"name,omitempty"`
	// The attribute `operations` is deprecated. Use `execution-mode` instead.
	Operations *value.Value[bool] `json:"operations,omitempty"`
	// Manages if Scalr exports the remote backend configuration and state storage for your infrastructure management. Disabling this feature will also prevent the ability to perform state locking, which ensures that concurrent operations do not conflict. Additionally, it will disable the capability to initiate CLI-driven runs through Scalr.
	RemoteBackend *value.Value[bool] `json:"remote-backend,omitempty"`
	// Specifies if the state is shared within the environment.
	RemoteStateSharing *value.Value[bool] `json:"remote-state-sharing,omitempty"`
	// The timeout for the Terraform Run operations (in minutes).
	RunOperationTimeout *value.Value[int] `json:"run-operation-timeout,omitempty"`
	// The version of Terraform the workspace performs runs on. If omitted, the system default version is assigned.
	TerraformVersion *value.Value[string]                     `json:"terraform-version,omitempty"`
	Terragrunt       *value.Value[WorkspaceTerragruntRequest] `json:"terragrunt,omitempty"`
	// The list of Terraform variables files.
	VarFiles *value.Value[[]string]                `json:"var-files,omitempty"`
	VcsRepo  *value.Value[WorkspaceVcsRepoRequest] `json:"vcs-repo,omitempty"`
	// A relative path where Terraform commands will execute in.
	WorkingDirectory *value.Value[string] `json:"working-directory,omitempty"`
}

// WorkspaceRelationshipsRequest holds the relationships for Workspace (request)
type WorkspaceRelationshipsRequest struct {
	// The ID of the agent pool used to execute run stages. Overrides the default account-level and environment-level pools.
	AgentPool *value.Value[AgentPool] `json:"agent-pool,omitempty"`
	// The environment this workspace belongs to.
	Environment *value.Value[Environment] `json:"environment,omitempty"`
	// The ID of the module version.
	ModuleVersion *value.Value[ModuleVersion] `json:"module-version,omitempty"`
	Tags          *value.Value[[]Tag]         `json:"tags,omitempty"`
	// VCS provider of the Run's workspace
	VcsProvider *value.Value[VcsProvider] `json:"vcs-provider,omitempty"`
}

type WorkspaceHooks struct {
	// Command that should be run after terraform apply operation executed.
	PostApply *string `json:"post-apply"`
	// Command that should be run after terraform plan operation executed.
	PostPlan *string `json:"post-plan"`
	// Command that should be run before terraform apply operation executed.
	PreApply *string `json:"pre-apply"`
	// Command that should be run before terraform init operation executed.
	PreInit *string `json:"pre-init"`
	// Command that should be run before terraform plan operation executed.
	PrePlan *string `json:"pre-plan"`
}

type WorkspaceTerragrunt struct {
	// Indicates whether the workspace includes external dependencies.
	IncludeExternalDependencies bool `json:"include-external-dependencies"`
	// Indicates whether the workspace uses `terragrunt run-all`.
	UseRunAll bool `json:"use-run-all"`
	// The version of Terragrunt the workspace performs runs on.
	Version string `json:"version"`
}

type WorkspaceVcsRepo struct {
	// Branch of a repository the workspace is associated with. If omitted, the repository default branch will be used. This option conflicts with `version_constraint`.
	Branch *string `json:"branch"`
	// When true once a pull request into the vcs-repo.branch is opened, every push to a pull request's branch will trigger a dry run in the workspace. Default `true`
	DryRunsEnabled bool `json:"dry-runs-enabled"`
	// A reference to your VCS repository. For GitHub, GitHub Enterprise and GitLab the format is `<org>/<repo>`. Azure DevOps Services has the format `<org>/<project>/<repo>`.
	Identifier string `json:"identifier"`
	// Specifies whether git submodules should be fetched when cloning the VCS repository.
	IngressSubmodules bool `json:"ingress-submodules"`
	// The attribute `vcs-repo.path` is deprecated. Use working-directory and trigger-prefixes instead.
	Path *string `json:"path"`
	// List of path patterns in gitignore format, whose changes will trigger a run for the workspace using this binding when the CV is created. Conflicts with 'trigger-prefixes'. If 'trigger-patterns' and 'trigger-prefixes' are omitted, any change in the configuration version root will trigger a new run.
	TriggerPatterns *string `json:"trigger-patterns"`
	// List of paths (relative to the configuration version root), whose changes will trigger a run for the workspace using this binding when the CV is created. Conflicts with 'trigger-patterns'. If 'trigger-patterns' and 'trigger-prefixes' are omitted, any change in the configuration version root will trigger a new run.
	TriggerPrefixes *[]string `json:"trigger-prefixes"`
	// Terraform-like version constraint used to trigger a run for matching Git tags. Only stable tags are supported in version ranges. Pre-release tags (e.g. `-rc`, `-beta`) must be specified exactly, e.g. `1.2.0-rc1`, to trigger a run. This option conflicts with `branch`.
	VersionConstraint *string `json:"version-constraint"`
}

type WorkspaceHooksRequest struct {
	// Command that should be run after terraform apply operation executed.
	PostApply *value.Value[string] `json:"post-apply,omitempty"`
	// Command that should be run after terraform plan operation executed.
	PostPlan *value.Value[string] `json:"post-plan,omitempty"`
	// Command that should be run before terraform apply operation executed.
	PreApply *value.Value[string] `json:"pre-apply,omitempty"`
	// Command that should be run before terraform init operation executed.
	PreInit *value.Value[string] `json:"pre-init,omitempty"`
	// Command that should be run before terraform plan operation executed.
	PrePlan *value.Value[string] `json:"pre-plan,omitempty"`
}

type WorkspaceTerragruntRequest struct {
	// Indicates whether the workspace includes external dependencies.
	IncludeExternalDependencies *value.Value[bool] `json:"include-external-dependencies,omitempty"`
	// Indicates whether the workspace uses `terragrunt run-all`.
	UseRunAll *value.Value[bool] `json:"use-run-all,omitempty"`
	// The version of Terragrunt the workspace performs runs on.
	Version *value.Value[string] `json:"version,omitempty"`
}

type WorkspaceVcsRepoRequest struct {
	// Branch of a repository the workspace is associated with. If omitted, the repository default branch will be used. This option conflicts with `version_constraint`.
	Branch *value.Value[string] `json:"branch,omitempty"`
	// When true once a pull request into the vcs-repo.branch is opened, every push to a pull request's branch will trigger a dry run in the workspace. Default `true`
	DryRunsEnabled *value.Value[bool] `json:"dry-runs-enabled,omitempty"`
	// A reference to your VCS repository. For GitHub, GitHub Enterprise and GitLab the format is `<org>/<repo>`. Azure DevOps Services has the format `<org>/<project>/<repo>`.
	Identifier *value.Value[string] `json:"identifier,omitempty"`
	// Specifies whether git submodules should be fetched when cloning the VCS repository.
	IngressSubmodules *value.Value[bool] `json:"ingress-submodules,omitempty"`
	// The attribute `vcs-repo.path` is deprecated. Use working-directory and trigger-prefixes instead.
	Path *value.Value[string] `json:"path,omitempty"`
	// List of path patterns in gitignore format, whose changes will trigger a run for the workspace using this binding when the CV is created. Conflicts with 'trigger-prefixes'. If 'trigger-patterns' and 'trigger-prefixes' are omitted, any change in the configuration version root will trigger a new run.
	TriggerPatterns *value.Value[string] `json:"trigger-patterns,omitempty"`
	// List of paths (relative to the configuration version root), whose changes will trigger a run for the workspace using this binding when the CV is created. Conflicts with 'trigger-patterns'. If 'trigger-patterns' and 'trigger-prefixes' are omitted, any change in the configuration version root will trigger a new run.
	TriggerPrefixes *value.Value[[]string] `json:"trigger-prefixes,omitempty"`
	// Terraform-like version constraint used to trigger a run for matching Git tags. Only stable tags are supported in version ranges. Pre-release tags (e.g. `-rc`, `-beta`) must be specified exactly, e.g. `1.2.0-rc1`, to trigger a run. This option conflicts with `branch`.
	VersionConstraint *value.Value[string] `json:"version-constraint,omitempty"`
}
