// Code generated by scalr-gen. DO NOT EDIT.

package schemas

import (
	"encoding/json"

	"github.com/scalr/go-scalr/v2/scalr/value"
)

// Response version - used when unmarshalling from API responses
// Grants the permissions declared in a role to a user, team, or service account. An access policy is applied to an environment or a specific workspace.
type AccessPolicy struct {
	ID            string                    `json:"id"`
	Type          string                    `json:"type"`
	Attributes    AccessPolicyAttributes    `json:"attributes"`
	Relationships AccessPolicyRelationships `json:"relationships"`
}

// GetID returns the resource ID (implements client.ResourceLike)
func (r AccessPolicy) GetID() string {
	return r.ID
}

// GetResourceType returns the JSON:API resource type (implements client.ResourceLike)
func (r AccessPolicy) GetResourceType() string {
	if r.Type != "" {
		return r.Type
	}
	return "access-policies"
}

// AccessPolicyAttributes holds the attributes for AccessPolicy (response)
type AccessPolicyAttributes struct {
	// The access policy is a built-in read-only policy that cannot be updated or deleted.
	IsSystem bool `json:"is-system"`
}

// AccessPolicyRelationships holds the relationships for AccessPolicy (response)
type AccessPolicyRelationships struct {
	// Grant access to the account and to all environments and workspaces in the account.
	Account *Account `json:"account"`
	// Grant access to the environment and all workspaces within it.
	Environment *Environment `json:"environment"`
	// The roles with permissions.
	Roles []*Role `json:"roles"`
	// Role binding to a service account.
	ServiceAccount *ServiceAccount `json:"service-account"`
	// Role binding to a team.
	Team *Team `json:"team"`
	// Role binding to a user.
	User *User `json:"user"`
	// Grant access to the workspace.
	Workspace *Workspace `json:"workspace"`
}

// UnmarshalJSON implements custom unmarshalling for relationships
func (r *AccessPolicyRelationships) UnmarshalJSON(data []byte) error {
	// Parse into temporary structure that matches JSON:API format
	var temp map[string]json.RawMessage
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}

	if raw, ok := temp["account"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Account = &Account{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["environment"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Environment = &Environment{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["roles"]; ok {
		// To-many relationship
		var rel struct {
			Data []struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Roles = make([]*Role, len(rel.Data))
			for i, d := range rel.Data {
				r.Roles[i] = &Role{
					ID:   d.ID,
					Type: d.Type,
				}
			}
		}
	}
	if raw, ok := temp["service-account"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.ServiceAccount = &ServiceAccount{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["team"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Team = &Team{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["user"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.User = &User{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["workspace"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Workspace = &Workspace{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	return nil
}

// PopulateIncludes merges included resources into the relationships
func (r *AccessPolicyRelationships) PopulateIncludes(included []map[string]interface{}) {
	if r == nil || len(included) == 0 {
		return
	}

	// Build a map of included resources by type+id for fast lookup
	includedMap := make(map[string]map[string]interface{})
	for _, inc := range included {
		if id, ok := inc["id"].(string); ok {
			if typ, ok := inc["type"].(string); ok {
				key := typ + ":" + id
				includedMap[key] = inc
			}
		}
	}

	// Populate to-one relationship: Account
	if r.Account != nil && r.Account.ID != "" {
		key := r.Account.Type + ":" + r.Account.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full Account
			if err := json.Unmarshal(data, &full); err == nil {
				r.Account = &full
			}
		}
	}
	// Populate to-one relationship: Environment
	if r.Environment != nil && r.Environment.ID != "" {
		key := r.Environment.Type + ":" + r.Environment.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full Environment
			if err := json.Unmarshal(data, &full); err == nil {
				r.Environment = &full
			}
		}
	}
	// Populate to-many relationship: Roles
	if r.Roles != nil {
		for i, resource := range r.Roles {
			if resource != nil && resource.ID != "" {
				key := resource.Type + ":" + resource.ID
				if fullResource, ok := includedMap[key]; ok {
					// Unmarshal the full resource
					data, _ := json.Marshal(fullResource)
					var full Role
					if err := json.Unmarshal(data, &full); err == nil {
						r.Roles[i] = &full
					}
				}
			}
		}
	}
	// Populate to-one relationship: ServiceAccount
	if r.ServiceAccount != nil && r.ServiceAccount.ID != "" {
		key := r.ServiceAccount.Type + ":" + r.ServiceAccount.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full ServiceAccount
			if err := json.Unmarshal(data, &full); err == nil {
				r.ServiceAccount = &full
			}
		}
	}
	// Populate to-one relationship: Team
	if r.Team != nil && r.Team.ID != "" {
		key := r.Team.Type + ":" + r.Team.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full Team
			if err := json.Unmarshal(data, &full); err == nil {
				r.Team = &full
			}
		}
	}
	// Populate to-one relationship: User
	if r.User != nil && r.User.ID != "" {
		key := r.User.Type + ":" + r.User.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full User
			if err := json.Unmarshal(data, &full); err == nil {
				r.User = &full
			}
		}
	}
	// Populate to-one relationship: Workspace
	if r.Workspace != nil && r.Workspace.ID != "" {
		key := r.Workspace.Type + ":" + r.Workspace.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full Workspace
			if err := json.Unmarshal(data, &full); err == nil {
				r.Workspace = &full
			}
		}
	}
}

// Request version - used when marshalling for API requests
// Grants the permissions declared in a role to a user, team, or service account. An access policy is applied to an environment or a specific workspace. (for requests)
type AccessPolicyRequest struct {
	ID            string                           `json:"id,omitempty"`
	Type          string                           `json:"type,omitempty"`
	Attributes    AccessPolicyAttributesRequest    `json:"attributes,omitempty"`
	Relationships AccessPolicyRelationshipsRequest `json:"relationships,omitempty"`
}

// MarshalJSON automatically sets the Type field during marshalling
func (r AccessPolicyRequest) MarshalJSON() ([]byte, error) {
	type Alias AccessPolicyRequest
	if r.Type == "" {
		r.Type = "access-policies"
	}
	return json.Marshal((Alias)(r))
}

// GetID returns the resource ID (implements client.ResourceLike)
func (r AccessPolicyRequest) GetID() string {
	return r.ID
}

// GetResourceType returns the JSON:API resource type (implements client.ResourceLike)
func (r AccessPolicyRequest) GetResourceType() string {
	return "access-policies"
}

// AccessPolicyAttributesRequest holds the attributes for AccessPolicy (request)
type AccessPolicyAttributesRequest struct {
}

// AccessPolicyRelationshipsRequest holds the relationships for AccessPolicy (request)
type AccessPolicyRelationshipsRequest struct {
	// Grant access to the account and to all environments and workspaces in the account.
	Account *value.Value[Account] `json:"account,omitempty"`
	// Grant access to the environment and all workspaces within it.
	Environment *value.Value[Environment] `json:"environment,omitempty"`
	// The roles with permissions.
	Roles *value.Value[[]Role] `json:"roles,omitempty"`
	// Role binding to a service account.
	ServiceAccount *value.Value[ServiceAccount] `json:"service-account,omitempty"`
	// Role binding to a team.
	Team *value.Value[Team] `json:"team,omitempty"`
	// Role binding to a user.
	User *value.Value[User] `json:"user,omitempty"`
	// Grant access to the workspace.
	Workspace *value.Value[Workspace] `json:"workspace,omitempty"`
}
