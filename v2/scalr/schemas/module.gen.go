// Code generated by scalr-gen. DO NOT EDIT.

package schemas

import (
	"encoding/json"
	"time"

	"github.com/scalr/go-scalr/v2/scalr/value"
)

// Response version - used when unmarshalling from API responses
// A terraform module in the [Private Module Registry](/docs/private-module-registry).
type Module struct {
	ID            string              `json:"id"`
	Type          string              `json:"type"`
	Attributes    ModuleAttributes    `json:"attributes"`
	Relationships ModuleRelationships `json:"relationships"`
}

// GetID returns the resource ID (implements client.ResourceLike)
func (r Module) GetID() string {
	return r.ID
}

// GetResourceType returns the JSON:API resource type (implements client.ResourceLike)
func (r Module) GetResourceType() string {
	if r.Type != "" {
		return r.Type
	}
	return "modules"
}

// ModuleAttributes holds the attributes for Module (response)
type ModuleAttributes struct {
	// The resource creation timestamp.
	CreatedAt time.Time `json:"created-at"`
	// The description of the module. By default, this is taken from the VCS repository description. For mono repos you likely want to override this behavior by passing this argument in a [Create Module](modules.html#create-a-module) operation.
	Description string `json:"description"`
	// This field contains the error description, when this module's status is `errored`.
	ErrorMessage *string `json:"error-message"`
	// The module name.
	Name string `json:"name"`
	// A name of a system, this module was written for. For multi-cloud modules this argument should match terraform provider name (ex: `aws` or `google`), in other cases the convention is to name it `system`
	Provider string `json:"provider"`
	// The `source` by which the module should be addressed from a HCL template.
	Source string `json:"source"`
	// The Module's current status. Initial status: * `pending` - The initial status of a module once it has been created. Now Scalr will download the code from the VCS, and create a `module-version` resource for each matching Git tag. Ending statuses: * `no_version_tags` - a Module has been created, however the Module source repository has no tags. * `setup_complete` - a Module has been created, and at least one ModuleVersion has been successfully uploaded. Scalr assigns this status while some module-versions upload might be still in-progress. If you want to ensure a specific version was uploaded, you can poll [List Module Versions](module-versions.html#list-module-versions) for the `ok` status. * `errored` - Module has been created, however its synchronization has failed. Attribute `error-message` contains the details.
	Status  string        `json:"status"`
	VcsRepo ModuleVcsRepo `json:"vcs-repo"`
}

// ModuleRelationships holds the relationships for Module (response)
type ModuleRelationships struct {
	// The relationship `account` is deprecated. Use `namespace` instead.
	Account *Account `json:"account"`
	// The user who has created the module.
	CreatedBy *User `json:"created-by"`
	// The relationship `environment` is deprecated. Use `namespace` instead.
	Environment *Environment `json:"environment"`
	// The module's latest version.
	LatestModuleVersion *ModuleVersion `json:"latest-module-version"`
	// The module's latest successful version.
	ModuleVersion *ModuleVersion `json:"module-version"`
	// The IDs of the module versions.
	ModuleVersions []*ModuleVersion `json:"module-versions"`
	// The module namespace this module belongs to.
	Namespace *ModuleNamespace `json:"namespace"`
	// The module's VCS provider.
	VcsProvider *VcsProvider `json:"vcs-provider"`
}

// UnmarshalJSON implements custom unmarshalling for relationships
func (r *ModuleRelationships) UnmarshalJSON(data []byte) error {
	// Parse into temporary structure that matches JSON:API format
	var temp map[string]json.RawMessage
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}

	if raw, ok := temp["account"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Account = &Account{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["created-by"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.CreatedBy = &User{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["environment"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Environment = &Environment{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["latest-module-version"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.LatestModuleVersion = &ModuleVersion{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["module-version"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.ModuleVersion = &ModuleVersion{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["module-versions"]; ok {
		// To-many relationship
		var rel struct {
			Data []struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.ModuleVersions = make([]*ModuleVersion, len(rel.Data))
			for i, d := range rel.Data {
				r.ModuleVersions[i] = &ModuleVersion{
					ID:   d.ID,
					Type: d.Type,
				}
			}
		}
	}
	if raw, ok := temp["namespace"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Namespace = &ModuleNamespace{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["vcs-provider"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.VcsProvider = &VcsProvider{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	return nil
}

// PopulateIncludes merges included resources into the relationships
func (r *ModuleRelationships) PopulateIncludes(included []map[string]interface{}) {
	if r == nil || len(included) == 0 {
		return
	}

	// Build a map of included resources by type+id for fast lookup
	includedMap := make(map[string]map[string]interface{})
	for _, inc := range included {
		if id, ok := inc["id"].(string); ok {
			if typ, ok := inc["type"].(string); ok {
				key := typ + ":" + id
				includedMap[key] = inc
			}
		}
	}

	// Populate to-one relationship: Account
	if r.Account != nil && r.Account.ID != "" {
		key := r.Account.Type + ":" + r.Account.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full Account
			if err := json.Unmarshal(data, &full); err == nil {
				r.Account = &full
			}
		}
	}
	// Populate to-one relationship: CreatedBy
	if r.CreatedBy != nil && r.CreatedBy.ID != "" {
		key := r.CreatedBy.Type + ":" + r.CreatedBy.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full User
			if err := json.Unmarshal(data, &full); err == nil {
				r.CreatedBy = &full
			}
		}
	}
	// Populate to-one relationship: Environment
	if r.Environment != nil && r.Environment.ID != "" {
		key := r.Environment.Type + ":" + r.Environment.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full Environment
			if err := json.Unmarshal(data, &full); err == nil {
				r.Environment = &full
			}
		}
	}
	// Populate to-one relationship: LatestModuleVersion
	if r.LatestModuleVersion != nil && r.LatestModuleVersion.ID != "" {
		key := r.LatestModuleVersion.Type + ":" + r.LatestModuleVersion.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full ModuleVersion
			if err := json.Unmarshal(data, &full); err == nil {
				r.LatestModuleVersion = &full
			}
		}
	}
	// Populate to-one relationship: ModuleVersion
	if r.ModuleVersion != nil && r.ModuleVersion.ID != "" {
		key := r.ModuleVersion.Type + ":" + r.ModuleVersion.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full ModuleVersion
			if err := json.Unmarshal(data, &full); err == nil {
				r.ModuleVersion = &full
			}
		}
	}
	// Populate to-many relationship: ModuleVersions
	if r.ModuleVersions != nil {
		for i, resource := range r.ModuleVersions {
			if resource != nil && resource.ID != "" {
				key := resource.Type + ":" + resource.ID
				if fullResource, ok := includedMap[key]; ok {
					// Unmarshal the full resource
					data, _ := json.Marshal(fullResource)
					var full ModuleVersion
					if err := json.Unmarshal(data, &full); err == nil {
						r.ModuleVersions[i] = &full
					}
				}
			}
		}
	}
	// Populate to-one relationship: Namespace
	if r.Namespace != nil && r.Namespace.ID != "" {
		key := r.Namespace.Type + ":" + r.Namespace.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full ModuleNamespace
			if err := json.Unmarshal(data, &full); err == nil {
				r.Namespace = &full
			}
		}
	}
	// Populate to-one relationship: VcsProvider
	if r.VcsProvider != nil && r.VcsProvider.ID != "" {
		key := r.VcsProvider.Type + ":" + r.VcsProvider.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full VcsProvider
			if err := json.Unmarshal(data, &full); err == nil {
				r.VcsProvider = &full
			}
		}
	}
}

// Request version - used when marshalling for API requests
// A terraform module in the [Private Module Registry](/docs/private-module-registry). (for requests)
type ModuleRequest struct {
	ID            string                     `json:"id,omitempty"`
	Type          string                     `json:"type,omitempty"`
	Attributes    ModuleAttributesRequest    `json:"attributes,omitempty"`
	Relationships ModuleRelationshipsRequest `json:"relationships,omitempty"`
}

// MarshalJSON automatically sets the Type field during marshalling
func (r ModuleRequest) MarshalJSON() ([]byte, error) {
	type Alias ModuleRequest
	if r.Type == "" {
		r.Type = "modules"
	}
	return json.Marshal((Alias)(r))
}

// GetID returns the resource ID (implements client.ResourceLike)
func (r ModuleRequest) GetID() string {
	return r.ID
}

// GetResourceType returns the JSON:API resource type (implements client.ResourceLike)
func (r ModuleRequest) GetResourceType() string {
	return "modules"
}

// ModuleAttributesRequest holds the attributes for Module (request)
type ModuleAttributesRequest struct {
	VcsRepo *value.Value[ModuleVcsRepoRequest] `json:"vcs-repo,omitempty"`
}

// ModuleRelationshipsRequest holds the relationships for Module (request)
type ModuleRelationshipsRequest struct {
	// The relationship `environment` is deprecated. Use `namespace` instead.
	Environment *value.Value[Environment] `json:"environment,omitempty"`
	// The module namespace this module belongs to.
	Namespace *value.Value[ModuleNamespace] `json:"namespace,omitempty"`
	// The module's VCS provider.
	VcsProvider *value.Value[VcsProvider] `json:"vcs-provider,omitempty"`
}

type ModuleVcsRepo struct {
	// A reference to the module's VCS repository. For GitHub, GitHub Enterprise and GitLab the format is `<org>/<repo>`. Azure DevOps Services has the format `<org>/<project>/<repo>`.
	Identifier string `json:"identifier"`
	// The repository sub-directory where the module source is located. If omitted or submitted as an empty string, this defaults to the repository's root.
	Path string `json:"path"`
	// Specify this attribute when a module's releases are namespaced within a repository's Git tags. This is usually the case for a mono repos with individually versioned components. For example if your module is tagged `my-module/v1.0.0` it's `tag_prefix` is `my-module/`.
	TagPrefix string `json:"tag-prefix"`
}

type ModuleVcsRepoRequest struct {
	// A reference to the module's VCS repository. For GitHub, GitHub Enterprise and GitLab the format is `<org>/<repo>`. Azure DevOps Services has the format `<org>/<project>/<repo>`.
	Identifier *value.Value[string] `json:"identifier,omitempty"`
	// The repository sub-directory where the module source is located. If omitted or submitted as an empty string, this defaults to the repository's root.
	Path *value.Value[string] `json:"path,omitempty"`
	// Specify this attribute when a module's releases are namespaced within a repository's Git tags. This is usually the case for a mono repos with individually versioned components. For example if your module is tagged `my-module/v1.0.0` it's `tag_prefix` is `my-module/`.
	TagPrefix *value.Value[string] `json:"tag-prefix,omitempty"`
}
