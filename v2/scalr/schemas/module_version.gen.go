// Code generated by scalr-gen. DO NOT EDIT.

package schemas

import (
	"encoding/json"
	"time"

	"github.com/scalr/go-scalr/v2/scalr/value"
)

// ModuleVersionStatus represents the type for ModuleVersionStatus
// The module version's current status. Initial status: * `not_uploaded` - Module version has been created, however the code has not been uploaded. Transitional statuses: * `pending` - Module version has been created and is currently synchronizing. * `pending_delete` - Module version has been deleted from the repository and pending deletion from the registry. Ending statuses: * `ok` - Module version has been created and the code has been uploaded. * `errored` - Module version has been created, however its synchronization has failed. Attribute `error-message` contains the details.
type ModuleVersionStatus string

// ModuleVersionStatus constants
const (
	ModuleVersionStatusNotUploaded   ModuleVersionStatus = "not_uploaded"
	ModuleVersionStatusPending       ModuleVersionStatus = "pending"
	ModuleVersionStatusOk            ModuleVersionStatus = "ok"
	ModuleVersionStatusErrored       ModuleVersionStatus = "errored"
	ModuleVersionStatusPendingDelete ModuleVersionStatus = "pending_delete"
)

// Response version - used when unmarshalling from API responses
// A terraform module's version in the [Private Module Registry](../../module.html).
type ModuleVersion struct {
	ID            string                     `json:"id"`
	Type          string                     `json:"type"`
	Attributes    ModuleVersionAttributes    `json:"attributes"`
	Relationships ModuleVersionRelationships `json:"relationships"`
}

// GetID returns the resource ID (implements client.ResourceLike)
func (r ModuleVersion) GetID() string {
	return r.ID
}

// GetResourceType returns the JSON:API resource type (implements client.ResourceLike)
func (r ModuleVersion) GetResourceType() string {
	if r.Type != "" {
		return r.Type
	}
	return "module-versions"
}

// ModuleVersionAttributes holds the attributes for ModuleVersion (response)
type ModuleVersionAttributes struct {
	// The resource creation timestamp.
	CreatedAt time.Time `json:"created-at"`
	// The list of modules this version depends on.
	Dependencies *map[string]interface{} `json:"dependencies"`
	// README contents. This file should be named README or README.md. The latter will be processed as [CommonMark](https://commonmark.org/).
	Details *string `json:"details"`
	// This field contains the error description, when this module version's status is `errored`.
	ErrorMessage *string `json:"error-message"`
	// Input Variables.
	Inputs *[]interface{} `json:"inputs"`
	// Module version marked as root will allow the [creation of workspaces](../../module.html#deployable-modules) directly from the registry, as well as standard module usage.
	IsRootModule bool `json:"is-root-module"`
	// Output Values.
	Outputs *[]map[string]interface{} `json:"outputs"`
	// Declared resources.
	Resources *[]map[string]interface{} `json:"resources"`
	// A blob size in bytes.
	Size *int `json:"size"`
	// The module version's current status. Initial status: * `not_uploaded` - Module version has been created, however the code has not been uploaded. Transitional statuses: * `pending` - Module version has been created and is currently synchronizing. * `pending_delete` - Module version has been deleted from the repository and pending deletion from the registry. Ending statuses: * `ok` - Module version has been created and the code has been uploaded. * `errored` - Module version has been created, however its synchronization has failed. Attribute `error-message` contains the details.
	Status ModuleVersionStatus `json:"status"`
	// Semantic Version.
	Version string `json:"version"`
}

// ModuleVersionRelationships holds the relationships for ModuleVersion (response)
type ModuleVersionRelationships struct {
	// The module this version belongs to.
	Module *Module `json:"module"`
	// The Git commit information when the module version was uploaded from a VCS.
	VcsRevision *VcsRevision `json:"vcs-revision"`
}

// UnmarshalJSON implements custom unmarshalling for relationships
func (r *ModuleVersionRelationships) UnmarshalJSON(data []byte) error {
	// Parse into temporary structure that matches JSON:API format
	var temp map[string]json.RawMessage
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}

	if raw, ok := temp["module"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Module = &Module{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["vcs-revision"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.VcsRevision = &VcsRevision{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	return nil
}

// PopulateIncludes merges included resources into the relationships
func (r *ModuleVersionRelationships) PopulateIncludes(included []map[string]interface{}) {
	if r == nil || len(included) == 0 {
		return
	}

	// Build a map of included resources by type+id for fast lookup
	includedMap := make(map[string]map[string]interface{})
	for _, inc := range included {
		if id, ok := inc["id"].(string); ok {
			if typ, ok := inc["type"].(string); ok {
				key := typ + ":" + id
				includedMap[key] = inc
			}
		}
	}

	// Populate to-one relationship: Module
	if r.Module != nil && r.Module.ID != "" {
		key := r.Module.Type + ":" + r.Module.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full Module
			if err := json.Unmarshal(data, &full); err == nil {
				r.Module = &full
			}
		}
	}
	// Populate to-one relationship: VcsRevision
	if r.VcsRevision != nil && r.VcsRevision.ID != "" {
		key := r.VcsRevision.Type + ":" + r.VcsRevision.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full VcsRevision
			if err := json.Unmarshal(data, &full); err == nil {
				r.VcsRevision = &full
			}
		}
	}
}

// Request version - used when marshalling for API requests
// A terraform module's version in the [Private Module Registry](../../module.html). (for requests)
type ModuleVersionRequest struct {
	ID            string                            `json:"id,omitempty"`
	Type          string                            `json:"type,omitempty"`
	Attributes    ModuleVersionAttributesRequest    `json:"attributes,omitempty"`
	Relationships ModuleVersionRelationshipsRequest `json:"relationships,omitempty"`
}

// MarshalJSON automatically sets the Type field during marshalling
func (r ModuleVersionRequest) MarshalJSON() ([]byte, error) {
	type Alias ModuleVersionRequest
	if r.Type == "" {
		r.Type = "module-versions"
	}
	return json.Marshal((Alias)(r))
}

// GetID returns the resource ID (implements client.ResourceLike)
func (r ModuleVersionRequest) GetID() string {
	return r.ID
}

// GetResourceType returns the JSON:API resource type (implements client.ResourceLike)
func (r ModuleVersionRequest) GetResourceType() string {
	return "module-versions"
}

// ModuleVersionAttributesRequest holds the attributes for ModuleVersion (request)
type ModuleVersionAttributesRequest struct {
	// Semantic Version.
	Version *value.Value[string] `json:"version,omitempty"`
}

// ModuleVersionRelationshipsRequest holds the relationships for ModuleVersion (request)
type ModuleVersionRelationshipsRequest struct {
	// The module this version belongs to.
	Module *value.Value[Module] `json:"module,omitempty"`
}
