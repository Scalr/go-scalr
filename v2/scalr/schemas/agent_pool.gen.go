// Code generated by scalr-gen. DO NOT EDIT.

package schemas

import (
	"encoding/json"

	"github.com/scalr/go-scalr/v2/scalr/value"
)

// Response version - used when unmarshalling from API responses
// With the agent pool resource you can manage a pool of [self-hosted agents](/docs/agent-pools) A workspace may be configured to use an agent pool to execute terraform [runs](/docs/workspaces-runs). Agents could be hosted on a physical or virtual machines within the customer's network.
type AgentPool struct {
	ID            string                 `json:"id"`
	Type          string                 `json:"type"`
	Attributes    AgentPoolAttributes    `json:"attributes"`
	Relationships AgentPoolRelationships `json:"relationships"`
}

// GetID returns the resource ID (implements client.ResourceLike)
func (r AgentPool) GetID() string {
	return r.ID
}

// GetResourceType returns the JSON:API resource type (implements client.ResourceLike)
func (r AgentPool) GetResourceType() string {
	if r.Type != "" {
		return r.Type
	}
	return "agent-pools"
}

// AgentPoolAttributes holds the attributes for AgentPool (response)
type AgentPoolAttributes struct {
	// Default agent pool for the entire account. Used by a workspace if no default pool is set at the environment level and no other pool is explicitly linked at the workspace level.
	Default bool `json:"default"`
	// The features enabled for all agents in the agent pool.
	Features []string `json:"features"`
	// Indicates whether the pool is used by any workspace.
	InUse bool `json:"in-use"`
	// Indicates whether the pool is managed by Scalr.
	IsScalrManaged bool `json:"is-scalr-managed"`
	// Indicates whether the pool is available in any environment of the account without being directly linked to it.
	IsShared bool `json:"is-shared"`
	// The name of the agent pool. This must be unique within a Scalr scope (e.g. account or environment).
	Name string `json:"name"`
	// Indicates whether the VCS support is enabled for agents in the pool.
	VcsEnabled bool `json:"vcs-enabled"`
	// Indicates whether the serverless agent support is enabled. If enabled, provided url will be informed about new work available for agent.
	WebhookEnabled bool `json:"webhook-enabled"`
	// A list of HTTP headers to be included in the request.
	WebhookHeaders *[]map[string]interface{} `json:"webhook-headers"`
	// HTTP(s) destination URL.
	WebhookUrl *string `json:"webhook-url"`
}

// AgentPoolRelationships holds the relationships for AgentPool (response)
type AgentPoolRelationships struct {
	// The account the agent pool belongs to.
	Account *Account `json:"account"`
	// The list of agents connected to the pool.
	Agents []*Agent `json:"agents"`
	// The environment the agent pool belongs to. This relationship is deprecated.
	Environment *Environment `json:"environment"`
	// The list of environments this pool is directly linked to.
	Environments []*Environment `json:"environments"`
	// The list of workspaces attached to the pool. Can be used to bulk link/unlink workspaces.
	Workspaces []*Workspace `json:"workspaces"`
}

// UnmarshalJSON implements custom unmarshalling for relationships
func (r *AgentPoolRelationships) UnmarshalJSON(data []byte) error {
	// Parse into temporary structure that matches JSON:API format
	var temp map[string]json.RawMessage
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}

	if raw, ok := temp["account"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Account = &Account{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["agents"]; ok {
		// To-many relationship
		var rel struct {
			Data []struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Agents = make([]*Agent, len(rel.Data))
			for i, d := range rel.Data {
				r.Agents[i] = &Agent{
					ID:   d.ID,
					Type: d.Type,
				}
			}
		}
	}
	if raw, ok := temp["environment"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Environment = &Environment{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["environments"]; ok {
		// To-many relationship
		var rel struct {
			Data []struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Environments = make([]*Environment, len(rel.Data))
			for i, d := range rel.Data {
				r.Environments[i] = &Environment{
					ID:   d.ID,
					Type: d.Type,
				}
			}
		}
	}
	if raw, ok := temp["workspaces"]; ok {
		// To-many relationship
		var rel struct {
			Data []struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Workspaces = make([]*Workspace, len(rel.Data))
			for i, d := range rel.Data {
				r.Workspaces[i] = &Workspace{
					ID:   d.ID,
					Type: d.Type,
				}
			}
		}
	}
	return nil
}

// PopulateIncludes merges included resources into the relationships
func (r *AgentPoolRelationships) PopulateIncludes(included []map[string]interface{}) {
	if r == nil || len(included) == 0 {
		return
	}

	// Build a map of included resources by type+id for fast lookup
	includedMap := make(map[string]map[string]interface{})
	for _, inc := range included {
		if id, ok := inc["id"].(string); ok {
			if typ, ok := inc["type"].(string); ok {
				key := typ + ":" + id
				includedMap[key] = inc
			}
		}
	}

	// Populate to-one relationship: Account
	if r.Account != nil && r.Account.ID != "" {
		key := r.Account.Type + ":" + r.Account.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full Account
			if err := json.Unmarshal(data, &full); err == nil {
				r.Account = &full
			}
		}
	}
	// Populate to-many relationship: Agents
	if r.Agents != nil {
		for i, resource := range r.Agents {
			if resource != nil && resource.ID != "" {
				key := resource.Type + ":" + resource.ID
				if fullResource, ok := includedMap[key]; ok {
					// Unmarshal the full resource
					data, _ := json.Marshal(fullResource)
					var full Agent
					if err := json.Unmarshal(data, &full); err == nil {
						r.Agents[i] = &full
					}
				}
			}
		}
	}
	// Populate to-one relationship: Environment
	if r.Environment != nil && r.Environment.ID != "" {
		key := r.Environment.Type + ":" + r.Environment.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full Environment
			if err := json.Unmarshal(data, &full); err == nil {
				r.Environment = &full
			}
		}
	}
	// Populate to-many relationship: Environments
	if r.Environments != nil {
		for i, resource := range r.Environments {
			if resource != nil && resource.ID != "" {
				key := resource.Type + ":" + resource.ID
				if fullResource, ok := includedMap[key]; ok {
					// Unmarshal the full resource
					data, _ := json.Marshal(fullResource)
					var full Environment
					if err := json.Unmarshal(data, &full); err == nil {
						r.Environments[i] = &full
					}
				}
			}
		}
	}
	// Populate to-many relationship: Workspaces
	if r.Workspaces != nil {
		for i, resource := range r.Workspaces {
			if resource != nil && resource.ID != "" {
				key := resource.Type + ":" + resource.ID
				if fullResource, ok := includedMap[key]; ok {
					// Unmarshal the full resource
					data, _ := json.Marshal(fullResource)
					var full Workspace
					if err := json.Unmarshal(data, &full); err == nil {
						r.Workspaces[i] = &full
					}
				}
			}
		}
	}
}

// Request version - used when marshalling for API requests
// With the agent pool resource you can manage a pool of [self-hosted agents](/docs/agent-pools) A workspace may be configured to use an agent pool to execute terraform [runs](/docs/workspaces-runs). Agents could be hosted on a physical or virtual machines within the customer's network. (for requests)
type AgentPoolRequest struct {
	ID            string                        `json:"id,omitempty"`
	Type          string                        `json:"type,omitempty"`
	Attributes    AgentPoolAttributesRequest    `json:"attributes,omitempty"`
	Relationships AgentPoolRelationshipsRequest `json:"relationships,omitempty"`
}

// MarshalJSON automatically sets the Type field during marshalling
func (r AgentPoolRequest) MarshalJSON() ([]byte, error) {
	type Alias AgentPoolRequest
	if r.Type == "" {
		r.Type = "agent-pools"
	}
	return json.Marshal((Alias)(r))
}

// GetID returns the resource ID (implements client.ResourceLike)
func (r AgentPoolRequest) GetID() string {
	return r.ID
}

// GetResourceType returns the JSON:API resource type (implements client.ResourceLike)
func (r AgentPoolRequest) GetResourceType() string {
	return "agent-pools"
}

// AgentPoolAttributesRequest holds the attributes for AgentPool (request)
type AgentPoolAttributesRequest struct {
	// Default agent pool for the entire account. Used by a workspace if no default pool is set at the environment level and no other pool is explicitly linked at the workspace level.
	Default *value.Value[bool] `json:"default,omitempty"`
	// Indicates whether the pool is available in any environment of the account without being directly linked to it.
	IsShared *value.Value[bool] `json:"is-shared,omitempty"`
	// The name of the agent pool. This must be unique within a Scalr scope (e.g. account or environment).
	Name *value.Value[string] `json:"name,omitempty"`
	// Indicates whether the VCS support is enabled for agents in the pool.
	VcsEnabled *value.Value[bool] `json:"vcs-enabled,omitempty"`
	// Indicates whether the serverless agent support is enabled. If enabled, provided url will be informed about new work available for agent.
	WebhookEnabled *value.Value[bool] `json:"webhook-enabled,omitempty"`
	// A list of HTTP headers to be included in the request.
	WebhookHeaders *value.Value[[]map[string]interface{}] `json:"webhook-headers,omitempty"`
	// HTTP(s) destination URL.
	WebhookUrl *value.Value[string] `json:"webhook-url,omitempty"`
}

// AgentPoolRelationshipsRequest holds the relationships for AgentPool (request)
type AgentPoolRelationshipsRequest struct {
	// The environment the agent pool belongs to. This relationship is deprecated.
	Environment *value.Value[Environment] `json:"environment,omitempty"`
	// The list of environments this pool is directly linked to.
	Environments *value.Value[[]Environment] `json:"environments,omitempty"`
	// The list of workspaces attached to the pool. Can be used to bulk link/unlink workspaces.
	Workspaces *value.Value[[]Workspace] `json:"workspaces,omitempty"`
}
