// Code generated by scalr-gen. DO NOT EDIT.

package schemas

import (
	"encoding/json"
	"time"

	"github.com/scalr/go-scalr/v2/scalr/value"
)

// Response version - used when unmarshalling from API responses
// Represents an IaCP Webhook integration delivery.
type WebhookIntegrationDelivery struct {
	ID            string                                  `json:"id"`
	Type          string                                  `json:"type"`
	Attributes    WebhookIntegrationDeliveryAttributes    `json:"attributes"`
	Relationships WebhookIntegrationDeliveryRelationships `json:"relationships"`
}

// GetID returns the resource ID (implements client.ResourceLike)
func (r WebhookIntegrationDelivery) GetID() string {
	return r.ID
}

// GetResourceType returns the JSON:API resource type (implements client.ResourceLike)
func (r WebhookIntegrationDelivery) GetResourceType() string {
	if r.Type != "" {
		return r.Type
	}
	return "webhook-integration-deliveries"
}

// WebhookIntegrationDeliveryAttributes holds the attributes for WebhookIntegrationDelivery (response)
type WebhookIntegrationDeliveryAttributes struct {
	// The number of attempts made to deliver the webhook.
	Attempts int `json:"attempts"`
	// The error message, if any, encountered during delivery.
	ErrorMessage string `json:"error-message"`
	// The Date/Time of the last attempt to deliver the webhook.
	LastHandleAttemptAt time.Time `json:"last-handle-attempt-at"`
	// The data payload (JSON format) sent in the webhook request body.
	RequestBody map[string]interface{} `json:"request-body"`
	// The HTTP request headers sent with the webhook.
	RequestHeaders map[string]interface{} `json:"request-headers"`
	// The data (JSON or plain text) received in the response body from the external system.
	ResponseBody interface{} `json:"response-body"`
	// The HTTP status code returned by the external system.
	ResponseCode int `json:"response-code"`
	// The HTTP response headers received from the external system.
	ResponseHeaders map[string]interface{} `json:"response-headers"`
	// The delivery status. Can be: `pending`, `completed`, or `failed`.
	Status string `json:"status"`
	// The Date/Time when the webhook was triggered.
	TriggeredAt time.Time `json:"triggered-at"`
}

// WebhookIntegrationDeliveryRelationships holds the relationships for WebhookIntegrationDelivery (response)
type WebhookIntegrationDeliveryRelationships struct {
	// The environment related to the webhook delivery.
	Environment *Environment `json:"environment"`
	// The specific event that triggered this webhook delivery.
	Event *EventDefinition `json:"event"`
	// The optional run associated with the webhook delivery.
	Run *Run `json:"run"`
	// The user who triggered the webhook.
	TriggeredBy *User `json:"triggered-by"`
	// The webhook this delivery belongs to.
	Webhook *WebhookIntegration `json:"webhook"`
	// The workspace related to the webhook delivery.
	Workspace *Workspace `json:"workspace"`
}

// UnmarshalJSON implements custom unmarshalling for relationships
func (r *WebhookIntegrationDeliveryRelationships) UnmarshalJSON(data []byte) error {
	// Parse into temporary structure that matches JSON:API format
	var temp map[string]json.RawMessage
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}

	if raw, ok := temp["environment"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Environment = &Environment{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["event"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Event = &EventDefinition{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["run"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Run = &Run{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["triggered-by"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.TriggeredBy = &User{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["webhook"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Webhook = &WebhookIntegration{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["workspace"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Workspace = &Workspace{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	return nil
}

// PopulateIncludes merges included resources into the relationships
func (r *WebhookIntegrationDeliveryRelationships) PopulateIncludes(included []map[string]interface{}) {
	if r == nil || len(included) == 0 {
		return
	}

	// Build a map of included resources by type+id for fast lookup
	includedMap := make(map[string]map[string]interface{})
	for _, inc := range included {
		if id, ok := inc["id"].(string); ok {
			if typ, ok := inc["type"].(string); ok {
				key := typ + ":" + id
				includedMap[key] = inc
			}
		}
	}

	// Populate to-one relationship: Environment
	if r.Environment != nil && r.Environment.ID != "" {
		key := r.Environment.Type + ":" + r.Environment.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full Environment
			if err := json.Unmarshal(data, &full); err == nil {
				r.Environment = &full
			}
		}
	}
	// Populate to-one relationship: Event
	if r.Event != nil && r.Event.ID != "" {
		key := r.Event.Type + ":" + r.Event.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full EventDefinition
			if err := json.Unmarshal(data, &full); err == nil {
				r.Event = &full
			}
		}
	}
	// Populate to-one relationship: Run
	if r.Run != nil && r.Run.ID != "" {
		key := r.Run.Type + ":" + r.Run.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full Run
			if err := json.Unmarshal(data, &full); err == nil {
				r.Run = &full
			}
		}
	}
	// Populate to-one relationship: TriggeredBy
	if r.TriggeredBy != nil && r.TriggeredBy.ID != "" {
		key := r.TriggeredBy.Type + ":" + r.TriggeredBy.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full User
			if err := json.Unmarshal(data, &full); err == nil {
				r.TriggeredBy = &full
			}
		}
	}
	// Populate to-one relationship: Webhook
	if r.Webhook != nil && r.Webhook.ID != "" {
		key := r.Webhook.Type + ":" + r.Webhook.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full WebhookIntegration
			if err := json.Unmarshal(data, &full); err == nil {
				r.Webhook = &full
			}
		}
	}
	// Populate to-one relationship: Workspace
	if r.Workspace != nil && r.Workspace.ID != "" {
		key := r.Workspace.Type + ":" + r.Workspace.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full Workspace
			if err := json.Unmarshal(data, &full); err == nil {
				r.Workspace = &full
			}
		}
	}
}

// Request version - used when marshalling for API requests
// Represents an IaCP Webhook integration delivery. (for requests)
type WebhookIntegrationDeliveryRequest struct {
	ID            string                                         `json:"id,omitempty"`
	Type          string                                         `json:"type,omitempty"`
	Attributes    WebhookIntegrationDeliveryAttributesRequest    `json:"attributes,omitempty"`
	Relationships WebhookIntegrationDeliveryRelationshipsRequest `json:"relationships,omitempty"`
}

// MarshalJSON automatically sets the Type field during marshalling
func (r WebhookIntegrationDeliveryRequest) MarshalJSON() ([]byte, error) {
	type Alias WebhookIntegrationDeliveryRequest
	if r.Type == "" {
		r.Type = "webhook-integration-deliveries"
	}
	return json.Marshal((Alias)(r))
}

// GetID returns the resource ID (implements client.ResourceLike)
func (r WebhookIntegrationDeliveryRequest) GetID() string {
	return r.ID
}

// GetResourceType returns the JSON:API resource type (implements client.ResourceLike)
func (r WebhookIntegrationDeliveryRequest) GetResourceType() string {
	return "webhook-integration-deliveries"
}

// WebhookIntegrationDeliveryAttributesRequest holds the attributes for WebhookIntegrationDelivery (request)
type WebhookIntegrationDeliveryAttributesRequest struct {
	// The number of attempts made to deliver the webhook.
	Attempts *value.Value[int] `json:"attempts,omitempty"`
	// The error message, if any, encountered during delivery.
	ErrorMessage *value.Value[string] `json:"error-message,omitempty"`
	// The Date/Time of the last attempt to deliver the webhook.
	LastHandleAttemptAt *value.Value[time.Time] `json:"last-handle-attempt-at,omitempty"`
	// The data payload (JSON format) sent in the webhook request body.
	RequestBody *value.Value[map[string]interface{}] `json:"request-body,omitempty"`
	// The HTTP request headers sent with the webhook.
	RequestHeaders *value.Value[map[string]interface{}] `json:"request-headers,omitempty"`
	// The data (JSON or plain text) received in the response body from the external system.
	ResponseBody *value.Value[interface{}] `json:"response-body,omitempty"`
	// The HTTP status code returned by the external system.
	ResponseCode *value.Value[int] `json:"response-code,omitempty"`
	// The HTTP response headers received from the external system.
	ResponseHeaders *value.Value[map[string]interface{}] `json:"response-headers,omitempty"`
	// The delivery status. Can be: `pending`, `completed`, or `failed`.
	Status *value.Value[string] `json:"status,omitempty"`
	// The Date/Time when the webhook was triggered.
	TriggeredAt *value.Value[time.Time] `json:"triggered-at,omitempty"`
}

// WebhookIntegrationDeliveryRelationshipsRequest holds the relationships for WebhookIntegrationDelivery (request)
type WebhookIntegrationDeliveryRelationshipsRequest struct {
	// The environment related to the webhook delivery.
	Environment *value.Value[Environment] `json:"environment,omitempty"`
	// The specific event that triggered this webhook delivery.
	Event *value.Value[EventDefinition] `json:"event,omitempty"`
	// The optional run associated with the webhook delivery.
	Run *value.Value[Run] `json:"run,omitempty"`
	// The user who triggered the webhook.
	TriggeredBy *value.Value[User] `json:"triggered-by,omitempty"`
	// The webhook this delivery belongs to.
	Webhook *value.Value[WebhookIntegration] `json:"webhook,omitempty"`
	// The workspace related to the webhook delivery.
	Workspace *value.Value[Workspace] `json:"workspace,omitempty"`
}
