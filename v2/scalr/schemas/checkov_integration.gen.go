// Code generated by scalr-gen. DO NOT EDIT.

package schemas

import (
	"encoding/json"

	"github.com/scalr/go-scalr/v2/scalr/value"
)

// Response version - used when unmarshalling from API responses

type CheckovIntegration struct {
	ID            string                          `json:"id"`
	Type          string                          `json:"type"`
	Attributes    CheckovIntegrationAttributes    `json:"attributes"`
	Relationships CheckovIntegrationRelationships `json:"relationships"`
}

// GetID returns the resource ID (implements client.ResourceLike)
func (r CheckovIntegration) GetID() string {
	return r.ID
}

// GetResourceType returns the JSON:API resource type (implements client.ResourceLike)
func (r CheckovIntegration) GetResourceType() string {
	if r.Type != "" {
		return r.Type
	}
	return "checkov-integrations"
}

// CheckovIntegrationAttributes holds the attributes for CheckovIntegration (response)
type CheckovIntegrationAttributes struct {
	// CLI parameters to be passed to checkov command.
	CliArgs *string `json:"cli-args"`
	// Message from service that points to nature of a problem.
	ErrMessage *string `json:"err-message"`
	// Indicates whether external checks should be enabled.
	ExternalChecksEnabled bool `json:"external-checks-enabled"`
	// Indicates whether the integration is available in any existing or future environments of the account without directly linking it.
	IsShared bool `json:"is-shared"`
	// Name of the Checkov integration.
	Name string `json:"name"`
	// Status of the integration.
	Status  string                     `json:"status"`
	VcsRepo *CheckovIntegrationVcsRepo `json:"vcs-repo"`
	// Version of Checkov to use.
	Version string `json:"version"`
}

// CheckovIntegrationRelationships holds the relationships for CheckovIntegration (response)
type CheckovIntegrationRelationships struct {
	// The list of environments this integration is linked to.
	Environments []*Environment `json:"environments"`
	// The external checks VCS provider.
	VcsProvider *VcsProvider `json:"vcs-provider"`
}

// UnmarshalJSON implements custom unmarshalling for relationships
func (r *CheckovIntegrationRelationships) UnmarshalJSON(data []byte) error {
	// Parse into temporary structure that matches JSON:API format
	var temp map[string]json.RawMessage
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}

	if raw, ok := temp["environments"]; ok {
		// To-many relationship
		var rel struct {
			Data []struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Environments = make([]*Environment, len(rel.Data))
			for i, d := range rel.Data {
				r.Environments[i] = &Environment{
					ID:   d.ID,
					Type: d.Type,
				}
			}
		}
	}
	if raw, ok := temp["vcs-provider"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.VcsProvider = &VcsProvider{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	return nil
}

// PopulateIncludes merges included resources into the relationships
func (r *CheckovIntegrationRelationships) PopulateIncludes(included []map[string]interface{}) {
	if r == nil || len(included) == 0 {
		return
	}

	// Build a map of included resources by type+id for fast lookup
	includedMap := make(map[string]map[string]interface{})
	for _, inc := range included {
		if id, ok := inc["id"].(string); ok {
			if typ, ok := inc["type"].(string); ok {
				key := typ + ":" + id
				includedMap[key] = inc
			}
		}
	}

	// Populate to-many relationship: Environments
	if r.Environments != nil {
		for i, resource := range r.Environments {
			if resource != nil && resource.ID != "" {
				key := resource.Type + ":" + resource.ID
				if fullResource, ok := includedMap[key]; ok {
					// Unmarshal the full resource
					data, _ := json.Marshal(fullResource)
					var full Environment
					if err := json.Unmarshal(data, &full); err == nil {
						r.Environments[i] = &full
					}
				}
			}
		}
	}
	// Populate to-one relationship: VcsProvider
	if r.VcsProvider != nil && r.VcsProvider.ID != "" {
		key := r.VcsProvider.Type + ":" + r.VcsProvider.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full VcsProvider
			if err := json.Unmarshal(data, &full); err == nil {
				r.VcsProvider = &full
			}
		}
	}
}

// Request version - used when marshalling for API requests

type CheckovIntegrationRequest struct {
	ID            string                                 `json:"id,omitempty"`
	Type          string                                 `json:"type,omitempty"`
	Attributes    CheckovIntegrationAttributesRequest    `json:"attributes,omitempty"`
	Relationships CheckovIntegrationRelationshipsRequest `json:"relationships,omitempty"`
}

// MarshalJSON automatically sets the Type field during marshalling
func (r CheckovIntegrationRequest) MarshalJSON() ([]byte, error) {
	type Alias CheckovIntegrationRequest
	if r.Type == "" {
		r.Type = "checkov-integrations"
	}
	return json.Marshal((Alias)(r))
}

// GetID returns the resource ID (implements client.ResourceLike)
func (r CheckovIntegrationRequest) GetID() string {
	return r.ID
}

// GetResourceType returns the JSON:API resource type (implements client.ResourceLike)
func (r CheckovIntegrationRequest) GetResourceType() string {
	return "checkov-integrations"
}

// CheckovIntegrationAttributesRequest holds the attributes for CheckovIntegration (request)
type CheckovIntegrationAttributesRequest struct {
	// CLI parameters to be passed to checkov command.
	CliArgs *value.Value[string] `json:"cli-args,omitempty"`
	// Indicates whether external checks should be enabled.
	ExternalChecksEnabled *value.Value[bool] `json:"external-checks-enabled,omitempty"`
	// Indicates whether the integration is available in any existing or future environments of the account without directly linking it.
	IsShared *value.Value[bool] `json:"is-shared,omitempty"`
	// Name of the Checkov integration.
	Name *value.Value[string] `json:"name,omitempty"`
	// Status of the integration.
	Status  *value.Value[string]                           `json:"status,omitempty"`
	VcsRepo *value.Value[CheckovIntegrationVcsRepoRequest] `json:"vcs-repo,omitempty"`
	// Version of Checkov to use.
	Version *value.Value[string] `json:"version,omitempty"`
}

// CheckovIntegrationRelationshipsRequest holds the relationships for CheckovIntegration (request)
type CheckovIntegrationRelationshipsRequest struct {
	// The list of environments this integration is linked to.
	Environments *value.Value[[]Environment] `json:"environments,omitempty"`
	// The external checks VCS provider.
	VcsProvider *value.Value[VcsProvider] `json:"vcs-provider,omitempty"`
}

type CheckovIntegrationVcsRepo struct {
	// Branch of a repository the Checkov custom checks are associated with.
	Branch string `json:"branch"`
	// A reference to your VCS repository. For GitHub, GitHub Enterprise and GitLab the format is `<org>/<repo>`. For Azure DevOps Services the format is `<org>/<project>/<repo>`.
	Identifier string `json:"identifier"`
	// The sub-directory of the VCS repository where Checkov checks are stored. If omitted or submitted as an empty string, this defaults to the repository's root.
	Path *string `json:"path"`
}

type CheckovIntegrationVcsRepoRequest struct {
	// Branch of a repository the Checkov custom checks are associated with.
	Branch *value.Value[string] `json:"branch,omitempty"`
	// A reference to your VCS repository. For GitHub, GitHub Enterprise and GitLab the format is `<org>/<repo>`. For Azure DevOps Services the format is `<org>/<project>/<repo>`.
	Identifier *value.Value[string] `json:"identifier,omitempty"`
	// The sub-directory of the VCS repository where Checkov checks are stored. If omitted or submitted as an empty string, this defaults to the repository's root.
	Path *value.Value[string] `json:"path,omitempty"`
}
