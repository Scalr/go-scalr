// Code generated by scalr-gen. DO NOT EDIT.

package schemas

import (
	"encoding/json"
	"time"

	"github.com/scalr/go-scalr/v2/scalr/value"
)

// Response version - used when unmarshalling from API responses
// Environments are collections of related workspaces that correspond to functional areas, SDLC stages, projects or any grouping that is required. An account can have multiple environments. Workspaces within an environment are where Terraform configurations are run to deploy infrastructure, and where state files are stored. An Environment can have set of policy groups assigned that are applied to all workspaces in the environment. The Environment can also have variables, credentials, registry modules, and VCS providers that are available to every workspace.
type Environment struct {
	ID            string                   `json:"id"`
	Type          string                   `json:"type"`
	Attributes    EnvironmentAttributes    `json:"attributes"`
	Relationships EnvironmentRelationships `json:"relationships"`
}

// GetID returns the resource ID (implements client.ResourceLike)
func (r Environment) GetID() string {
	return r.ID
}

// GetResourceType returns the JSON:API resource type (implements client.ResourceLike)
func (r Environment) GetResourceType() string {
	if r.Type != "" {
		return r.Type
	}
	return "environments"
}

// EnvironmentAttributes holds the attributes for Environment (response)
type EnvironmentAttributes struct {
	// Date/Time the environment was created.
	CreatedAt      time.Time `json:"created-at"`
	CreatedByEmail *string   `json:"created-by-email"`
	// Allow all current and future environments to have access to this environment.
	IsFederatedToAccount bool `json:"is-federated-to-account"`
	// Enable masking of the sensitive console output.
	MaskSensitiveOutput bool `json:"mask-sensitive-output"`
	// The name of the environment.
	Name        string                 `json:"name"`
	Permissions map[string]interface{} `json:"permissions"`
	// Manages if Scalr exports the remote backend configuration and state storage for your infrastructure management. Disabling this feature will also prevent the ability to perform state locking, which ensures that concurrent operations do not conflict. Additionally, it will disable the capability to initiate CLI-driven runs through Scalr.
	RemoteBackend bool `json:"remote-backend"`
	// Indicates if the remote backend configuration can be overridden on the workspace level.
	RemoteBackendOverridable bool   `json:"remote-backend-overridable"`
	Status                   string `json:"status"`
}

// EnvironmentRelationships holds the relationships for Environment (response)
type EnvironmentRelationships struct {
	// The account that owns this environment.
	Account *Account `json:"account"`
	// The user that created the environment.
	CreatedBy *User `json:"created-by"`
	// Provider configurations used in the environment workspaces by default.
	DefaultProviderConfigurations []*ProviderConfiguration `json:"default-provider-configurations"`
	// Default agent pool that will be set for the entire environment. It will be used by a workspace if no other pool is explicitly linked.
	DefaultWorkspaceAgentPool *AgentPool `json:"default-workspace-agent-pool"`
	// The drift detection schedules for this environment
	DriftDetectionSchedules []*DriftDetectionSchedule `json:"drift-detection-schedules"`
	PolicyGroups            []*PolicyGroup            `json:"policy-groups"`
	// Provider configurations available for this environment.
	ProviderConfigurations []*ProviderConfiguration `json:"provider-configurations"`
	// The storage profile for this environment. If not set, the account's default storage profile will be used.
	StorageProfile *StorageProfile `json:"storage-profile"`
	Tags           []*Tag          `json:"tags"`
}

// UnmarshalJSON implements custom unmarshalling for relationships
func (r *EnvironmentRelationships) UnmarshalJSON(data []byte) error {
	// Parse into temporary structure that matches JSON:API format
	var temp map[string]json.RawMessage
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}

	if raw, ok := temp["account"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Account = &Account{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["created-by"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.CreatedBy = &User{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["default-provider-configurations"]; ok {
		// To-many relationship
		var rel struct {
			Data []struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.DefaultProviderConfigurations = make([]*ProviderConfiguration, len(rel.Data))
			for i, d := range rel.Data {
				r.DefaultProviderConfigurations[i] = &ProviderConfiguration{
					ID:   d.ID,
					Type: d.Type,
				}
			}
		}
	}
	if raw, ok := temp["default-workspace-agent-pool"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.DefaultWorkspaceAgentPool = &AgentPool{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["drift-detection-schedules"]; ok {
		// To-many relationship
		var rel struct {
			Data []struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.DriftDetectionSchedules = make([]*DriftDetectionSchedule, len(rel.Data))
			for i, d := range rel.Data {
				r.DriftDetectionSchedules[i] = &DriftDetectionSchedule{
					ID:   d.ID,
					Type: d.Type,
				}
			}
		}
	}
	if raw, ok := temp["policy-groups"]; ok {
		// To-many relationship
		var rel struct {
			Data []struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.PolicyGroups = make([]*PolicyGroup, len(rel.Data))
			for i, d := range rel.Data {
				r.PolicyGroups[i] = &PolicyGroup{
					ID:   d.ID,
					Type: d.Type,
				}
			}
		}
	}
	if raw, ok := temp["provider-configurations"]; ok {
		// To-many relationship
		var rel struct {
			Data []struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.ProviderConfigurations = make([]*ProviderConfiguration, len(rel.Data))
			for i, d := range rel.Data {
				r.ProviderConfigurations[i] = &ProviderConfiguration{
					ID:   d.ID,
					Type: d.Type,
				}
			}
		}
	}
	if raw, ok := temp["storage-profile"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.StorageProfile = &StorageProfile{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["tags"]; ok {
		// To-many relationship
		var rel struct {
			Data []struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Tags = make([]*Tag, len(rel.Data))
			for i, d := range rel.Data {
				r.Tags[i] = &Tag{
					ID:   d.ID,
					Type: d.Type,
				}
			}
		}
	}
	return nil
}

// PopulateIncludes merges included resources into the relationships
func (r *EnvironmentRelationships) PopulateIncludes(included []map[string]interface{}) {
	if r == nil || len(included) == 0 {
		return
	}

	// Build a map of included resources by type+id for fast lookup
	includedMap := make(map[string]map[string]interface{})
	for _, inc := range included {
		if id, ok := inc["id"].(string); ok {
			if typ, ok := inc["type"].(string); ok {
				key := typ + ":" + id
				includedMap[key] = inc
			}
		}
	}

	// Populate to-one relationship: Account
	if r.Account != nil && r.Account.ID != "" {
		key := r.Account.Type + ":" + r.Account.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full Account
			if err := json.Unmarshal(data, &full); err == nil {
				r.Account = &full
			}
		}
	}
	// Populate to-one relationship: CreatedBy
	if r.CreatedBy != nil && r.CreatedBy.ID != "" {
		key := r.CreatedBy.Type + ":" + r.CreatedBy.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full User
			if err := json.Unmarshal(data, &full); err == nil {
				r.CreatedBy = &full
			}
		}
	}
	// Populate to-many relationship: DefaultProviderConfigurations
	if r.DefaultProviderConfigurations != nil {
		for i, resource := range r.DefaultProviderConfigurations {
			if resource != nil && resource.ID != "" {
				key := resource.Type + ":" + resource.ID
				if fullResource, ok := includedMap[key]; ok {
					// Unmarshal the full resource
					data, _ := json.Marshal(fullResource)
					var full ProviderConfiguration
					if err := json.Unmarshal(data, &full); err == nil {
						r.DefaultProviderConfigurations[i] = &full
					}
				}
			}
		}
	}
	// Populate to-one relationship: DefaultWorkspaceAgentPool
	if r.DefaultWorkspaceAgentPool != nil && r.DefaultWorkspaceAgentPool.ID != "" {
		key := r.DefaultWorkspaceAgentPool.Type + ":" + r.DefaultWorkspaceAgentPool.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full AgentPool
			if err := json.Unmarshal(data, &full); err == nil {
				r.DefaultWorkspaceAgentPool = &full
			}
		}
	}
	// Populate to-many relationship: DriftDetectionSchedules
	if r.DriftDetectionSchedules != nil {
		for i, resource := range r.DriftDetectionSchedules {
			if resource != nil && resource.ID != "" {
				key := resource.Type + ":" + resource.ID
				if fullResource, ok := includedMap[key]; ok {
					// Unmarshal the full resource
					data, _ := json.Marshal(fullResource)
					var full DriftDetectionSchedule
					if err := json.Unmarshal(data, &full); err == nil {
						r.DriftDetectionSchedules[i] = &full
					}
				}
			}
		}
	}
	// Populate to-many relationship: PolicyGroups
	if r.PolicyGroups != nil {
		for i, resource := range r.PolicyGroups {
			if resource != nil && resource.ID != "" {
				key := resource.Type + ":" + resource.ID
				if fullResource, ok := includedMap[key]; ok {
					// Unmarshal the full resource
					data, _ := json.Marshal(fullResource)
					var full PolicyGroup
					if err := json.Unmarshal(data, &full); err == nil {
						r.PolicyGroups[i] = &full
					}
				}
			}
		}
	}
	// Populate to-many relationship: ProviderConfigurations
	if r.ProviderConfigurations != nil {
		for i, resource := range r.ProviderConfigurations {
			if resource != nil && resource.ID != "" {
				key := resource.Type + ":" + resource.ID
				if fullResource, ok := includedMap[key]; ok {
					// Unmarshal the full resource
					data, _ := json.Marshal(fullResource)
					var full ProviderConfiguration
					if err := json.Unmarshal(data, &full); err == nil {
						r.ProviderConfigurations[i] = &full
					}
				}
			}
		}
	}
	// Populate to-one relationship: StorageProfile
	if r.StorageProfile != nil && r.StorageProfile.ID != "" {
		key := r.StorageProfile.Type + ":" + r.StorageProfile.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full StorageProfile
			if err := json.Unmarshal(data, &full); err == nil {
				r.StorageProfile = &full
			}
		}
	}
	// Populate to-many relationship: Tags
	if r.Tags != nil {
		for i, resource := range r.Tags {
			if resource != nil && resource.ID != "" {
				key := resource.Type + ":" + resource.ID
				if fullResource, ok := includedMap[key]; ok {
					// Unmarshal the full resource
					data, _ := json.Marshal(fullResource)
					var full Tag
					if err := json.Unmarshal(data, &full); err == nil {
						r.Tags[i] = &full
					}
				}
			}
		}
	}
}

// Request version - used when marshalling for API requests
// Environments are collections of related workspaces that correspond to functional areas, SDLC stages, projects or any grouping that is required. An account can have multiple environments. Workspaces within an environment are where Terraform configurations are run to deploy infrastructure, and where state files are stored. An Environment can have set of policy groups assigned that are applied to all workspaces in the environment. The Environment can also have variables, credentials, registry modules, and VCS providers that are available to every workspace. (for requests)
type EnvironmentRequest struct {
	ID            string                          `json:"id,omitempty"`
	Type          string                          `json:"type,omitempty"`
	Attributes    EnvironmentAttributesRequest    `json:"attributes,omitempty"`
	Relationships EnvironmentRelationshipsRequest `json:"relationships,omitempty"`
}

// MarshalJSON automatically sets the Type field during marshalling
func (r EnvironmentRequest) MarshalJSON() ([]byte, error) {
	type Alias EnvironmentRequest
	if r.Type == "" {
		r.Type = "environments"
	}
	return json.Marshal((Alias)(r))
}

// GetID returns the resource ID (implements client.ResourceLike)
func (r EnvironmentRequest) GetID() string {
	return r.ID
}

// GetResourceType returns the JSON:API resource type (implements client.ResourceLike)
func (r EnvironmentRequest) GetResourceType() string {
	return "environments"
}

// EnvironmentAttributesRequest holds the attributes for Environment (request)
type EnvironmentAttributesRequest struct {
	// Allow all current and future environments to have access to this environment.
	IsFederatedToAccount *value.Value[bool] `json:"is-federated-to-account,omitempty"`
	// Enable masking of the sensitive console output.
	MaskSensitiveOutput *value.Value[bool] `json:"mask-sensitive-output,omitempty"`
	// The name of the environment.
	Name *value.Value[string] `json:"name,omitempty"`
	// Manages if Scalr exports the remote backend configuration and state storage for your infrastructure management. Disabling this feature will also prevent the ability to perform state locking, which ensures that concurrent operations do not conflict. Additionally, it will disable the capability to initiate CLI-driven runs through Scalr.
	RemoteBackend *value.Value[bool] `json:"remote-backend,omitempty"`
	// Indicates if the remote backend configuration can be overridden on the workspace level.
	RemoteBackendOverridable *value.Value[bool] `json:"remote-backend-overridable,omitempty"`
}

// EnvironmentRelationshipsRequest holds the relationships for Environment (request)
type EnvironmentRelationshipsRequest struct {
	// Provider configurations used in the environment workspaces by default.
	DefaultProviderConfigurations *value.Value[[]ProviderConfiguration] `json:"default-provider-configurations,omitempty"`
	// Default agent pool that will be set for the entire environment. It will be used by a workspace if no other pool is explicitly linked.
	DefaultWorkspaceAgentPool *value.Value[AgentPool] `json:"default-workspace-agent-pool,omitempty"`
	// The storage profile for this environment. If not set, the account's default storage profile will be used.
	StorageProfile *value.Value[StorageProfile] `json:"storage-profile,omitempty"`
	Tags           *value.Value[[]Tag]          `json:"tags,omitempty"`
}
