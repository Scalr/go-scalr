// Code generated by scalr-gen. DO NOT EDIT.

package schemas

import (
	"encoding/json"
	"time"

	"github.com/scalr/go-scalr/v2/scalr/value"
)

// AiUsageRequestType represents the type for AiUsageRequestType
// The type of the AI action request.
type AiUsageRequestType string

// AiUsageRequestType constants
const (
	AiUsageRequestTypeExplain   AiUsageRequestType = "explain"
	AiUsageRequestTypeSummarize AiUsageRequestType = "summarize"
)

// AiUsageModel represents the type for AiUsageModel
// The AI model name used to process the request.
type AiUsageModel string

// AiUsageModel constants
const (
	AiUsageModelClaude AiUsageModel = "claude"
)

// Response version - used when unmarshalling from API responses
// Represents the AI usage item.
type AiUsage struct {
	ID            string               `json:"id"`
	Type          string               `json:"type"`
	Attributes    AiUsageAttributes    `json:"attributes"`
	Relationships AiUsageRelationships `json:"relationships"`
}

// GetID returns the resource ID (implements client.ResourceLike)
func (r AiUsage) GetID() string {
	return r.ID
}

// GetResourceType returns the JSON:API resource type (implements client.ResourceLike)
func (r AiUsage) GetResourceType() string {
	if r.Type != "" {
		return r.Type
	}
	return "ai-usages"
}

// AiUsageAttributes holds the attributes for AiUsage (response)
type AiUsageAttributes struct {
	// The AI model name used to process the request.
	Model AiUsageModel `json:"model"`
	// The type of the AI action request.
	RequestType AiUsageRequestType `json:"request-type"`
	// The time when the AI action was requested.
	RequestedAt time.Time `json:"requested-at"`
	// The email of the user who requested the AI action.
	RequestedByEmail *string `json:"requested-by-email"`
}

// AiUsageRelationships holds the relationships for AiUsage (response)
type AiUsageRelationships struct {
	// The account this resource belongs to.
	Account *Account `json:"account"`
	// The run for which the AI action was requested.
	Run *Run `json:"run"`
}

// UnmarshalJSON implements custom unmarshalling for relationships
func (r *AiUsageRelationships) UnmarshalJSON(data []byte) error {
	// Parse into temporary structure that matches JSON:API format
	var temp map[string]json.RawMessage
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}

	if raw, ok := temp["account"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Account = &Account{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["run"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Run = &Run{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	return nil
}

// PopulateIncludes merges included resources into the relationships
func (r *AiUsageRelationships) PopulateIncludes(included []map[string]interface{}) {
	if r == nil || len(included) == 0 {
		return
	}

	// Build a map of included resources by type+id for fast lookup
	includedMap := make(map[string]map[string]interface{})
	for _, inc := range included {
		if id, ok := inc["id"].(string); ok {
			if typ, ok := inc["type"].(string); ok {
				key := typ + ":" + id
				includedMap[key] = inc
			}
		}
	}

	// Populate to-one relationship: Account
	if r.Account != nil && r.Account.ID != "" {
		key := r.Account.Type + ":" + r.Account.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full Account
			if err := json.Unmarshal(data, &full); err == nil {
				r.Account = &full
			}
		}
	}
	// Populate to-one relationship: Run
	if r.Run != nil && r.Run.ID != "" {
		key := r.Run.Type + ":" + r.Run.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full Run
			if err := json.Unmarshal(data, &full); err == nil {
				r.Run = &full
			}
		}
	}
}

// Request version - used when marshalling for API requests
// Represents the AI usage item. (for requests)
type AiUsageRequest struct {
	ID            string                      `json:"id,omitempty"`
	Type          string                      `json:"type,omitempty"`
	Attributes    AiUsageAttributesRequest    `json:"attributes,omitempty"`
	Relationships AiUsageRelationshipsRequest `json:"relationships,omitempty"`
}

// MarshalJSON automatically sets the Type field during marshalling
func (r AiUsageRequest) MarshalJSON() ([]byte, error) {
	type Alias AiUsageRequest
	if r.Type == "" {
		r.Type = "ai-usages"
	}
	return json.Marshal((Alias)(r))
}

// GetID returns the resource ID (implements client.ResourceLike)
func (r AiUsageRequest) GetID() string {
	return r.ID
}

// GetResourceType returns the JSON:API resource type (implements client.ResourceLike)
func (r AiUsageRequest) GetResourceType() string {
	return "ai-usages"
}

// AiUsageAttributesRequest holds the attributes for AiUsage (request)
type AiUsageAttributesRequest struct {
	// The AI model name used to process the request.
	Model *value.Value[AiUsageModel] `json:"model,omitempty"`
	// The type of the AI action request.
	RequestType *value.Value[AiUsageRequestType] `json:"request-type,omitempty"`
	// The time when the AI action was requested.
	RequestedAt *value.Value[time.Time] `json:"requested-at,omitempty"`
	// The email of the user who requested the AI action.
	RequestedByEmail *value.Value[string] `json:"requested-by-email,omitempty"`
}

// AiUsageRelationshipsRequest holds the relationships for AiUsage (request)
type AiUsageRelationshipsRequest struct {
	// The account this resource belongs to.
	Account *value.Value[Account] `json:"account,omitempty"`
	// The run for which the AI action was requested.
	Run *value.Value[Run] `json:"run,omitempty"`
}
