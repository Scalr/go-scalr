// Code generated by scalr-gen. DO NOT EDIT.

package schemas

import (
	"encoding/json"
	"time"

	"github.com/scalr/go-scalr/v2/scalr/value"
)

// PolicyGroupExecuteAs represents the type for PolicyGroupExecuteAs
// The stage of the run to evaluate the policy group.
type PolicyGroupExecuteAs string

// PolicyGroupExecuteAs constants
const (
	PolicyGroupExecuteAsPrePlanCheck PolicyGroupExecuteAs = "pre_plan_check"
	PolicyGroupExecuteAsPolicyCheck  PolicyGroupExecuteAs = "policy_check"
)

// PolicyGroupStatus represents the type for PolicyGroupStatus
// Policy group current status. * `fetching` - waiting for policies to be synchronized with VCS. * `active` - synchronization completed, policy group is ready. * `errored` - synchronization has failed. Attribute `error-message` contains the details.
type PolicyGroupStatus string

// PolicyGroupStatus constants
const (
	PolicyGroupStatusFetching PolicyGroupStatus = "fetching"
	PolicyGroupStatusActive   PolicyGroupStatus = "active"
	PolicyGroupStatusErrored  PolicyGroupStatus = "errored"
)

// Response version - used when unmarshalling from API responses
// A policy group represents the collection of [OPA](/docs/policy-governance#open-policy-agent) policies stored in a VCS repository. When [linked to an environment](/docs/assign-policies), the policy group will participate in the policy check phase of every run in that environment.
type PolicyGroup struct {
	ID            string                   `json:"id"`
	Type          string                   `json:"type"`
	Attributes    PolicyGroupAttributes    `json:"attributes"`
	Relationships PolicyGroupRelationships `json:"relationships"`
}

// GetID returns the resource ID (implements client.ResourceLike)
func (r PolicyGroup) GetID() string {
	return r.ID
}

// GetResourceType returns the JSON:API resource type (implements client.ResourceLike)
func (r PolicyGroup) GetResourceType() string {
	if r.Type != "" {
		return r.Type
	}
	return "policy-groups"
}

// PolicyGroupAttributes holds the attributes for PolicyGroup (response)
type PolicyGroupAttributes struct {
	// An absolute path from the repository root to the folder that contains common rego functions.
	CommonFunctionsFolder *string `json:"common-functions-folder"`
	// Date/Time the policy group was created.
	CreatedAt time.Time `json:"created-at"`
	// This field contains the error description when the group's status is `errored`.
	ErrorMessage *string `json:"error-message"`
	// The stage of the run to evaluate the policy group.
	ExecuteAs PolicyGroupExecuteAs `json:"execute-as"`
	// Indicates whether the policy group is enforced in all environments.
	IsEnforced bool `json:"is-enforced"`
	// The policy group name must be unique within the account and contain only letters, numbers, dashes
	Name string `json:"name"`
	// The version of Open Policy Agent to use for the policy evaluation. If omitted, the system default version is assigned.
	OpaVersion string `json:"opa-version"`
	// Policy group current status. * `fetching` - waiting for policies to be synchronized with VCS. * `active` - synchronization completed, policy group is ready. * `errored` - synchronization has failed. Attribute `error-message` contains the details.
	Status  PolicyGroupStatus  `json:"status"`
	VcsRepo PolicyGroupVcsRepo `json:"vcs-repo"`
}

// PolicyGroupRelationships holds the relationships for PolicyGroup (response)
type PolicyGroupRelationships struct {
	// The account this policy group belongs to.
	Account *Account `json:"account"`
	// List of environments this policy group is linked to.
	Environments []*Environment `json:"environments"`
	// List of OPA policies this group contains.
	Policies []*Policy `json:"policies"`
	// The policy group's VCS provider.
	VcsProvider *VcsProvider `json:"vcs-provider"`
	// The Git commit information when the policy group was fetched from VCS.
	VcsRevision *VcsRevision `json:"vcs-revision"`
}

// UnmarshalJSON implements custom unmarshalling for relationships
func (r *PolicyGroupRelationships) UnmarshalJSON(data []byte) error {
	// Parse into temporary structure that matches JSON:API format
	var temp map[string]json.RawMessage
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}

	if raw, ok := temp["account"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Account = &Account{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["environments"]; ok {
		// To-many relationship
		var rel struct {
			Data []struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Environments = make([]*Environment, len(rel.Data))
			for i, d := range rel.Data {
				r.Environments[i] = &Environment{
					ID:   d.ID,
					Type: d.Type,
				}
			}
		}
	}
	if raw, ok := temp["policies"]; ok {
		// To-many relationship
		var rel struct {
			Data []struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Policies = make([]*Policy, len(rel.Data))
			for i, d := range rel.Data {
				r.Policies[i] = &Policy{
					ID:   d.ID,
					Type: d.Type,
				}
			}
		}
	}
	if raw, ok := temp["vcs-provider"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.VcsProvider = &VcsProvider{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["vcs-revision"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.VcsRevision = &VcsRevision{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	return nil
}

// PopulateIncludes merges included resources into the relationships
func (r *PolicyGroupRelationships) PopulateIncludes(included []map[string]interface{}) {
	if r == nil || len(included) == 0 {
		return
	}

	// Build a map of included resources by type+id for fast lookup
	includedMap := make(map[string]map[string]interface{})
	for _, inc := range included {
		if id, ok := inc["id"].(string); ok {
			if typ, ok := inc["type"].(string); ok {
				key := typ + ":" + id
				includedMap[key] = inc
			}
		}
	}

	// Populate to-one relationship: Account
	if r.Account != nil && r.Account.ID != "" {
		key := r.Account.Type + ":" + r.Account.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full Account
			if err := json.Unmarshal(data, &full); err == nil {
				r.Account = &full
			}
		}
	}
	// Populate to-many relationship: Environments
	if r.Environments != nil {
		for i, resource := range r.Environments {
			if resource != nil && resource.ID != "" {
				key := resource.Type + ":" + resource.ID
				if fullResource, ok := includedMap[key]; ok {
					// Unmarshal the full resource
					data, _ := json.Marshal(fullResource)
					var full Environment
					if err := json.Unmarshal(data, &full); err == nil {
						r.Environments[i] = &full
					}
				}
			}
		}
	}
	// Populate to-many relationship: Policies
	if r.Policies != nil {
		for i, resource := range r.Policies {
			if resource != nil && resource.ID != "" {
				key := resource.Type + ":" + resource.ID
				if fullResource, ok := includedMap[key]; ok {
					// Unmarshal the full resource
					data, _ := json.Marshal(fullResource)
					var full Policy
					if err := json.Unmarshal(data, &full); err == nil {
						r.Policies[i] = &full
					}
				}
			}
		}
	}
	// Populate to-one relationship: VcsProvider
	if r.VcsProvider != nil && r.VcsProvider.ID != "" {
		key := r.VcsProvider.Type + ":" + r.VcsProvider.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full VcsProvider
			if err := json.Unmarshal(data, &full); err == nil {
				r.VcsProvider = &full
			}
		}
	}
	// Populate to-one relationship: VcsRevision
	if r.VcsRevision != nil && r.VcsRevision.ID != "" {
		key := r.VcsRevision.Type + ":" + r.VcsRevision.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full VcsRevision
			if err := json.Unmarshal(data, &full); err == nil {
				r.VcsRevision = &full
			}
		}
	}
}

// Request version - used when marshalling for API requests
// A policy group represents the collection of [OPA](/docs/policy-governance#open-policy-agent) policies stored in a VCS repository. When [linked to an environment](/docs/assign-policies), the policy group will participate in the policy check phase of every run in that environment. (for requests)
type PolicyGroupRequest struct {
	ID            string                          `json:"id,omitempty"`
	Type          string                          `json:"type,omitempty"`
	Attributes    PolicyGroupAttributesRequest    `json:"attributes,omitempty"`
	Relationships PolicyGroupRelationshipsRequest `json:"relationships,omitempty"`
}

// MarshalJSON automatically sets the Type field during marshalling
func (r PolicyGroupRequest) MarshalJSON() ([]byte, error) {
	type Alias PolicyGroupRequest
	if r.Type == "" {
		r.Type = "policy-groups"
	}
	return json.Marshal((Alias)(r))
}

// GetID returns the resource ID (implements client.ResourceLike)
func (r PolicyGroupRequest) GetID() string {
	return r.ID
}

// GetResourceType returns the JSON:API resource type (implements client.ResourceLike)
func (r PolicyGroupRequest) GetResourceType() string {
	return "policy-groups"
}

// PolicyGroupAttributesRequest holds the attributes for PolicyGroup (request)
type PolicyGroupAttributesRequest struct {
	// An absolute path from the repository root to the folder that contains common rego functions.
	CommonFunctionsFolder *value.Value[string] `json:"common-functions-folder,omitempty"`
	// The stage of the run to evaluate the policy group.
	ExecuteAs *value.Value[PolicyGroupExecuteAs] `json:"execute-as,omitempty"`
	// Indicates whether the policy group is enforced in all environments.
	IsEnforced *value.Value[bool] `json:"is-enforced,omitempty"`
	// The policy group name must be unique within the account and contain only letters, numbers, dashes
	Name *value.Value[string] `json:"name,omitempty"`
	// The version of Open Policy Agent to use for the policy evaluation. If omitted, the system default version is assigned.
	OpaVersion *value.Value[string]                    `json:"opa-version,omitempty"`
	VcsRepo    *value.Value[PolicyGroupVcsRepoRequest] `json:"vcs-repo,omitempty"`
}

// PolicyGroupRelationshipsRequest holds the relationships for PolicyGroup (request)
type PolicyGroupRelationshipsRequest struct {
	// The account this policy group belongs to.
	Account *value.Value[Account] `json:"account,omitempty"`
	// The policy group's VCS provider.
	VcsProvider *value.Value[VcsProvider] `json:"vcs-provider,omitempty"`
}

type PolicyGroupVcsRepo struct {
	// Branch of a repository the policy group is associated with. If omitted, the repository default branch will be used.
	Branch *string `json:"branch"`
	// A reference to your VCS repository. For GitHub, GitHub Enterprise and GitLab the format is `<org>/<repo>`. For Azure DevOps Services the format is `<org>/<project>/<repo>`.
	Identifier string `json:"identifier"`
	// The sub-directory of the VCS repository where OPA policies are stored. The `scalr-policy.hcl` file must exist in this directory. Files and directories outside this directory will be ignored during a sync from VCS, and changing them won't trigger a policy group update. If omitted or submitted as an empty string, this defaults to the repository's root.
	Path *string `json:"path"`
}

type PolicyGroupVcsRepoRequest struct {
	// Branch of a repository the policy group is associated with. If omitted, the repository default branch will be used.
	Branch *value.Value[string] `json:"branch,omitempty"`
	// A reference to your VCS repository. For GitHub, GitHub Enterprise and GitLab the format is `<org>/<repo>`. For Azure DevOps Services the format is `<org>/<project>/<repo>`.
	Identifier *value.Value[string] `json:"identifier,omitempty"`
	// The sub-directory of the VCS repository where OPA policies are stored. The `scalr-policy.hcl` file must exist in this directory. Files and directories outside this directory will be ignored during a sync from VCS, and changing them won't trigger a policy group update. If omitted or submitted as an empty string, this defaults to the repository's root.
	Path *value.Value[string] `json:"path,omitempty"`
}
