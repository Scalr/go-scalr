// Code generated by scalr-gen. DO NOT EDIT.

package schemas

import (
	"encoding/json"
	"time"

	"github.com/scalr/go-scalr/v2/scalr/value"
)

// Response version - used when unmarshalling from API responses
// A trust configuration that maps authenticated workload identities to specific service account.
type AssumeServiceAccountPolicy struct {
	ID            string                                  `json:"id"`
	Type          string                                  `json:"type"`
	Attributes    AssumeServiceAccountPolicyAttributes    `json:"attributes"`
	Relationships AssumeServiceAccountPolicyRelationships `json:"relationships"`
}

// GetID returns the resource ID (implements client.ResourceLike)
func (r AssumeServiceAccountPolicy) GetID() string {
	return r.ID
}

// GetResourceType returns the JSON:API resource type (implements client.ResourceLike)
func (r AssumeServiceAccountPolicy) GetResourceType() string {
	if r.Type != "" {
		return r.Type
	}
	return "assume-service-account-policies"
}

// AssumeServiceAccountPolicyAttributes holds the attributes for AssumeServiceAccountPolicy (response)
type AssumeServiceAccountPolicyAttributes struct {
	// A claim mapping, defining the conditions under which the workload identity can impersonate the service account..
	ClaimConditions []map[string]interface{} `json:"claim-conditions"`
	// The UTC datetime at which the assume service account policy was created.
	CreatedAt time.Time `json:"created-at"`
	// Email of the user who created assume service account policy.
	CreatedByEmail *string `json:"created-by-email"`
	// The maximum validity period, in seconds, for the token generated during the impersonation operation. Default: 3600 seconds or 1 hour. Range: 3600-43200 seconds (1-12 hours).
	MaximumSessionDuration *int `json:"maximum-session-duration"`
	// The assume service account policy name.
	Name string `json:"name"`
}

// AssumeServiceAccountPolicyRelationships holds the relationships for AssumeServiceAccountPolicy (response)
type AssumeServiceAccountPolicyRelationships struct {
	Provider       *WorkloadIdentityProvider `json:"provider"`
	ServiceAccount *ServiceAccount           `json:"service-account"`
}

// UnmarshalJSON implements custom unmarshalling for relationships
func (r *AssumeServiceAccountPolicyRelationships) UnmarshalJSON(data []byte) error {
	// Parse into temporary structure that matches JSON:API format
	var temp map[string]json.RawMessage
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}

	if raw, ok := temp["provider"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.Provider = &WorkloadIdentityProvider{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	if raw, ok := temp["service-account"]; ok {
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.ServiceAccount = &ServiceAccount{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
	}
	return nil
}

// PopulateIncludes merges included resources into the relationships
func (r *AssumeServiceAccountPolicyRelationships) PopulateIncludes(included []map[string]interface{}) {
	if r == nil || len(included) == 0 {
		return
	}

	// Build a map of included resources by type+id for fast lookup
	includedMap := make(map[string]map[string]interface{})
	for _, inc := range included {
		if id, ok := inc["id"].(string); ok {
			if typ, ok := inc["type"].(string); ok {
				key := typ + ":" + id
				includedMap[key] = inc
			}
		}
	}

	// Populate to-one relationship: Provider
	if r.Provider != nil && r.Provider.ID != "" {
		key := r.Provider.Type + ":" + r.Provider.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full WorkloadIdentityProvider
			if err := json.Unmarshal(data, &full); err == nil {
				r.Provider = &full
			}
		}
	}
	// Populate to-one relationship: ServiceAccount
	if r.ServiceAccount != nil && r.ServiceAccount.ID != "" {
		key := r.ServiceAccount.Type + ":" + r.ServiceAccount.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full ServiceAccount
			if err := json.Unmarshal(data, &full); err == nil {
				r.ServiceAccount = &full
			}
		}
	}
}

// Request version - used when marshalling for API requests
// A trust configuration that maps authenticated workload identities to specific service account. (for requests)
type AssumeServiceAccountPolicyRequest struct {
	ID            string                                         `json:"id,omitempty"`
	Type          string                                         `json:"type,omitempty"`
	Attributes    AssumeServiceAccountPolicyAttributesRequest    `json:"attributes,omitempty"`
	Relationships AssumeServiceAccountPolicyRelationshipsRequest `json:"relationships,omitempty"`
}

// MarshalJSON automatically sets the Type field during marshalling
func (r AssumeServiceAccountPolicyRequest) MarshalJSON() ([]byte, error) {
	type Alias AssumeServiceAccountPolicyRequest
	if r.Type == "" {
		r.Type = "assume-service-account-policies"
	}
	return json.Marshal((Alias)(r))
}

// GetID returns the resource ID (implements client.ResourceLike)
func (r AssumeServiceAccountPolicyRequest) GetID() string {
	return r.ID
}

// GetResourceType returns the JSON:API resource type (implements client.ResourceLike)
func (r AssumeServiceAccountPolicyRequest) GetResourceType() string {
	return "assume-service-account-policies"
}

// AssumeServiceAccountPolicyAttributesRequest holds the attributes for AssumeServiceAccountPolicy (request)
type AssumeServiceAccountPolicyAttributesRequest struct {
	// A claim mapping, defining the conditions under which the workload identity can impersonate the service account..
	ClaimConditions *value.Value[[]map[string]interface{}] `json:"claim-conditions,omitempty"`
	// The maximum validity period, in seconds, for the token generated during the impersonation operation. Default: 3600 seconds or 1 hour. Range: 3600-43200 seconds (1-12 hours).
	MaximumSessionDuration *value.Value[int] `json:"maximum-session-duration,omitempty"`
	// The assume service account policy name.
	Name *value.Value[string] `json:"name,omitempty"`
}

// AssumeServiceAccountPolicyRelationshipsRequest holds the relationships for AssumeServiceAccountPolicy (request)
type AssumeServiceAccountPolicyRelationshipsRequest struct {
	Provider *value.Value[WorkloadIdentityProvider] `json:"provider,omitempty"`
}
