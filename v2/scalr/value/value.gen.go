// Code generated by scalr-gen. DO NOT EDIT.

package value

import (
	"bytes"
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/scalr/go-scalr/v2/internal/generator/static/client"
)

// Value represents a field value that can be unset, explicitly nil, or have a value (tri-state).
// This is crucial for API POST/PATCH operations where we need to distinguish between:
//
// 1. Not setting a field (omit from payload):
//   - Use: Unset[T]() or nil or omit the field entirely
//   - Result: Field not included in JSON payload
//
// 2. Explicitly setting to null (null will be included in payload):
//   - Use: Null[T]()
//   - Result: Field included as null in JSON payload
//
// 3. Setting to empty (zero) value (send empty array/string/etc):
//   - Use: Set(emptyValue) like Set("") or Set([]string{})
//   - Result: Field included with empty value in JSON payload
//
// 4. Setting to actual value:
//   - Use: Set(value)
//   - Result: Field included with value in JSON payload
//
// Note: Unset() and nil are equivalent:
//
//	field: value.Unset[string]()   // Explicit intent
//	field: nil                     // More idiomatic
//	// (field omitted)             // Clean, preferred
type Value[T any] struct {
	value *T
	isSet bool
}

// Set creates a Value with the given value
func Set[T any](val T) *Value[T] {
	return &Value[T]{
		value: &val,
		isSet: true,
	}
}

// SetPtr creates a Value from a pointer
func SetPtr[T any](val *T) *Value[T] {
	if val == nil {
		return Null[T]()
	}
	return &Value[T]{
		value: val,
		isSet: true,
	}
}

// Null creates a Value that is explicitly set to null
// The field will be included in JSON as null
func Null[T any]() *Value[T] {
	return &Value[T]{
		value: nil,
		isSet: true,
	}
}

// Unset returns nil, which will be omitted from JSON with omitempty tag
// This is equivalent to setting the field to nil or omitting it entirely
func Unset[T any]() *Value[T] {
	return nil
}

// IsSet returns true if the value has been set (even if to null)
func (t *Value[T]) IsSet() bool {
	if t == nil {
		return false
	}
	return t.isSet
}

// IsNull returns true if the value is explicitly set to null
func (t *Value[T]) IsNull() bool {
	if t == nil {
		return false
	}
	return t.isSet && t.value == nil
}

// Value returns the value and whether it's set
func (t *Value[T]) Value() (T, bool) {
	var zero T
	if t == nil || !t.isSet || t.value == nil {
		return zero, false
	}
	return *t.value, true
}

// Ptr returns a pointer to the value, or nil if not set/null
func (t *Value[T]) Ptr() *T {
	if t == nil || !t.isSet {
		return nil
	}
	return t.value
}

// MustValue returns the value or panics if not set
func (t *Value[T]) MustValue() T {
	v, ok := t.Value()
	if !ok {
		panic("Value value is not set")
	}
	return v
}

// Set sets the value
func (t *Value[T]) Set(value T) {
	t.value = &value
	t.isSet = true
}

// SetPtr sets the value from a pointer
func (t *Value[T]) SetPtr(value *T) {
	if value == nil {
		t.SetNull()
		return
	}
	t.value = value
	t.isSet = true
}

// SetNull sets the value to explicitly null
func (t *Value[T]) SetNull() {
	t.value = nil
	t.isSet = true
}

// Clear unsets the value.
func (t *Value[T]) Clear() {
	if t == nil {
		return
	}
	t.value = nil
	t.isSet = false
}

// MarshalJSON implements json.Marshaler
func (t *Value[T]) MarshalJSON() ([]byte, error) {
	if t == nil || !t.isSet {
		// Unset values should be omitted from JSON via omitempty tag
		// If this is called, it means omitempty isn't working or field doesn't have it
		// Return null as a fallback (though this shouldn't happen)
		return []byte("null"), nil
	}

	if t.value == nil {
		// Explicitly null - for relationships this means {"data": null}
		if isRelationshipType[T]() {
			return json.Marshal(map[string]interface{}{"data": nil})
		}
		return []byte("null"), nil
	}

	// Check if this is a client.ResourceLike type (relationship)
	if resource, ok := any(*t.value).(client.ResourceLike); ok {
		// Single resource - wrap in JSON:API relationship format
		return json.Marshal(map[string]interface{}{
			"data": map[string]string{
				"id":   resource.GetID(),
				"type": resource.GetResourceType(),
			},
		})
	}

	// Check if this is a slice of client.ResourceLike (to-many relationship)
	if isSliceOfResourceLike(*t.value) {
		return marshalResourceSlice(*t.value)
	}

	// Marshal the actual value (not a relationship)
	return json.Marshal(t.value)
}

// isRelationshipType checks if T is a relationship type
// by checking if it's client.ResourceLike or slice of client.ResourceLike
func isRelationshipType[T any]() bool {
	var zero T
	// Check if it's a client.ResourceLike
	if _, ok := any(zero).(client.ResourceLike); ok {
		return true
	}
	// Check if it's a slice of ResourceLike
	rv := reflect.TypeOf(zero)
	if rv != nil && rv.Kind() == reflect.Slice {
		// Check if the element type implements client.ResourceLike
		elemType := rv.Elem()
		if elemType.Kind() == reflect.Struct {
			// Create a zero value and check if it implements the interface
			zeroElem := reflect.New(elemType).Elem().Interface()
			if _, ok := zeroElem.(client.ResourceLike); ok {
				return true
			}
		}
	}
	return false
}

// isSliceOfResourceLike checks if a value is a slice of client.ResourceLike
func isSliceOfResourceLike(v interface{}) bool {
	rv := reflect.ValueOf(v)
	if rv.Kind() != reflect.Slice {
		return false
	}

	// Check if the first element implements the client.ResourceLike interface
	if rv.Len() > 0 {
		elem := rv.Index(0).Interface()
		_, ok := elem.(client.ResourceLike)
		return ok
	}

	// For empty slices check the element type
	elemType := rv.Type().Elem()
	// Check if a zero value of the element type implements client.ResourceLike
	if elemType.Kind() == reflect.Struct {
		zero := reflect.New(elemType).Elem().Interface()
		_, ok := zero.(client.ResourceLike)
		return ok
	}

	return false
}

// marshalResourceSlice marshals a slice of resources as a JSON:API to-many relationship
func marshalResourceSlice(v interface{}) ([]byte, error) {
	rv := reflect.ValueOf(v)
	if rv.Kind() != reflect.Slice {
		return nil, fmt.Errorf("expected slice, got %T", v)
	}

	data := make([]map[string]string, 0, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		elem := rv.Index(i).Interface()
		if resource, ok := elem.(client.ResourceLike); ok {
			data = append(data, map[string]string{
				"id":   resource.GetID(),
				"type": resource.GetResourceType(),
			})
		}
	}

	return json.Marshal(map[string]interface{}{"data": data})
}

// UnmarshalJSON implements json.Unmarshaler
func (t *Value[T]) UnmarshalJSON(data []byte) error {
	t.isSet = true

	if bytes.Equal(data, []byte("null")) {
		t.value = nil
		return nil
	}

	var value T
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}

	t.value = &value
	return nil
}

// String implements Stringer
func (t *Value[T]) String() string {
	if t == nil || !t.isSet {
		return "<unset>"
	}
	if t.value == nil {
		return "<null>"
	}
	return fmt.Sprintf("%v", *t.value)
}
