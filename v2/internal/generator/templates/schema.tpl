// Code generated by scalr-gen. DO NOT EDIT.

package schemas

import (
	"encoding/json"
	"time"
	
	"github.com/scalr/go-scalr/v2/{{ .ApiPackageName }}/value"
)

{{range .EnumTypes}}
// {{ .Name }} represents the type for {{ .Name }}
{{if .Description}}// {{ .Description }}{{end}}
type {{ .Name }} {{ .BaseType }}

// {{ .Name }} constants
const (
{{- $enumTypeName := .Name}}
{{- $baseType := .BaseType}}
{{- range .Values}}
	{{- if eq $baseType "string"}}
	{{.Name}} {{$enumTypeName}} = "{{.Value}}"
	{{- else}}
	{{.Name}} {{$enumTypeName}} = {{.Value}}
	{{- end}}
{{- end}}
)

{{end}}

// Response version - used when unmarshalling from API responses
{{if .Description}}// {{ .Description }}{{end}}
type {{ .Name }} struct {
	ID            string                   `json:"id"`
	Type          string                   `json:"type"`
	{{if .Attributes}}Attributes    {{ .Name }}Attributes     `json:"attributes"`{{end}}
	{{if .Relationships}}Relationships {{ .Name }}Relationships `json:"relationships"`{{end}}
}

// GetID returns the resource ID (implements client.ResourceLike)
func (r {{ .Name }}) GetID() string {
	return r.ID
}

// GetResourceType returns the JSON:API resource type (implements client.ResourceLike)
func (r {{ .Name }}) GetResourceType() string {
	if r.Type != "" {
		return r.Type
	}
	return "{{ .TypeName }}"
}

{{if .Attributes}}
// {{ .Name }}Attributes holds the attributes for {{ .Name }} (response)
type {{ .Name }}Attributes struct {
{{range .Attributes -}}
	{{if .Description}}// {{ .Description }}
	{{end -}}
	{{.Name}} {{.ResponseType}} `json:"{{.JSONName}}"`
{{end -}}
}
{{end}}

{{if .Relationships}}
// {{ .Name }}Relationships holds the relationships for {{ .Name }} (response)
type {{ .Name }}Relationships struct {
{{range .Relationships -}}
	{{if .Description}}// {{ .Description }}
	{{end -}}
	{{if .ToMany -}}
		{{.Name}} []*{{ .Type }} `json:"{{.JSONName}}"`
	{{else -}}
		{{.Name}} *{{ .Type }} `json:"{{.JSONName}}"`
	{{end -}}
{{end -}}
}

// UnmarshalJSON implements custom unmarshalling for relationships
func (r *{{ .Name }}Relationships) UnmarshalJSON(data []byte) error {
	// Parse into temporary structure that matches JSON:API format
	var temp map[string]json.RawMessage
	if err := json.Unmarshal(data, &temp); err != nil {
		return err
	}

	{{range .Relationships -}}
	if raw, ok := temp["{{.JSONName}}"]; ok {
		{{if .ToMany -}}
		// To-many relationship
		var rel struct {
			Data []struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.{{.Name}} = make([]*{{ .Type }}, len(rel.Data))
			for i, d := range rel.Data {
				r.{{.Name}}[i] = &{{ .Type }}{
					ID:   d.ID,
					Type: d.Type,
				}
			}
		}
		{{else -}}
		// To-one relationship
		var rel struct {
			Data *struct {
				ID   string `json:"id"`
				Type string `json:"type"`
			} `json:"data"`
		}
		if err := json.Unmarshal(raw, &rel); err != nil {
			return err
		}
		if rel.Data != nil {
			r.{{.Name}} = &{{ .Type }}{
				ID:   rel.Data.ID,
				Type: rel.Data.Type,
			}
		}
		{{end -}}
	}
	{{end -}}

	return nil
}

// PopulateIncludes merges included resources into the relationships
func (r *{{ .Name }}Relationships) PopulateIncludes(included []map[string]interface{}) {
	if r == nil || len(included) == 0 {
		return
	}

	// Build a map of included resources by type+id for fast lookup
	includedMap := make(map[string]map[string]interface{})
	for _, inc := range included {
		if id, ok := inc["id"].(string); ok {
			if typ, ok := inc["type"].(string); ok {
				key := typ + ":" + id
				includedMap[key] = inc
			}
		}
	}

	{{range .Relationships -}}
	{{if .ToMany -}}
	// Populate to-many relationship: {{.Name}}
	if r.{{.Name}} != nil {
		for i, resource := range r.{{.Name}} {
			if resource != nil && resource.ID != "" {
				key := resource.Type + ":" + resource.ID
				if fullResource, ok := includedMap[key]; ok {
					// Unmarshal the full resource
					data, _ := json.Marshal(fullResource)
					var full {{ .Type }}
					if err := json.Unmarshal(data, &full); err == nil {
						r.{{.Name}}[i] = &full
					}
				}
			}
		}
	}
	{{else -}}
	// Populate to-one relationship: {{.Name}}
	if r.{{.Name}} != nil && r.{{.Name}}.ID != "" {
		key := r.{{.Name}}.Type + ":" + r.{{.Name}}.ID
		if fullResource, ok := includedMap[key]; ok {
			// Unmarshal the full resource
			data, _ := json.Marshal(fullResource)
			var full {{ .Type }}
			if err := json.Unmarshal(data, &full); err == nil {
				r.{{.Name}} = &full
			}
		}
	}
	{{end -}}
	{{end -}}
}
{{end}}

// Request version - used when marshalling for API requests
{{if .Description}}// {{ .Description }} (for requests){{end}}
type {{ .Name }}Request struct {
	ID            string                          `json:"id,omitempty"`
	Type          string                          `json:"type,omitempty"`
	{{if .Attributes}}Attributes    {{ .Name }}AttributesRequest    `json:"attributes,omitempty"`{{end}}
	{{if .Relationships}}Relationships {{ .Name }}RelationshipsRequest `json:"relationships,omitempty"`{{end}}
}

// MarshalJSON automatically sets the Type field during marshalling
func (r {{ .Name }}Request) MarshalJSON() ([]byte, error) {
	type Alias {{ .Name }}Request
	if r.Type == "" {
		r.Type = "{{ .TypeName }}"
	}
	return json.Marshal((Alias)(r))
}

// GetID returns the resource ID (implements client.ResourceLike)
func (r {{ .Name }}Request) GetID() string {
	return r.ID
}

// GetResourceType returns the JSON:API resource type (implements client.ResourceLike)
func (r {{ .Name }}Request) GetResourceType() string {
	return "{{ .TypeName }}"
}

{{if .Attributes}}
// {{ .Name }}AttributesRequest holds the attributes for {{ .Name }} (request)
type {{ .Name }}AttributesRequest struct {
{{range .Attributes -}}
	{{if not .ReadOnly -}}
	{{if .Description}}// {{ .Description }}
	{{end -}}
	{{.Name}} {{.RequestType}} `json:"{{.JSONName}},omitempty"`
	{{end -}}
{{end -}}
}
{{end}}

{{if .Relationships}}
// {{ .Name }}RelationshipsRequest holds the relationships for {{ .Name }} (request)
type {{ .Name }}RelationshipsRequest struct {
{{range .Relationships -}}
	{{if not .ReadOnly -}}
	{{if .Description}}// {{ .Description }}
	{{end -}}
	{{if .ToMany -}}
		{{.Name}} *value.Value[[]{{ .Type }}] `json:"{{.JSONName}},omitempty"`
	{{else -}}
		{{.Name}} *value.Value[{{ .Type }}] `json:"{{.JSONName}},omitempty"`
	{{end -}}
	{{end -}}
{{end -}}
}
{{end}}

{{range .NestedStructs}}
{{if .Description}}// {{ .Description }}{{end}}
type {{ .Name }} struct {
{{range .Fields -}}
	{{if .Description}}// {{ .Description }}
	{{end -}}
	{{.Name}} {{.Type}} `json:"{{.JSONName}}"`
{{end -}}
}

{{end}}

{{range .RequestNestedStructs}}
{{if .Description}}// {{ .Description }} (for requests){{end}}
type {{ .Name }} struct {
{{range .Fields -}}
	{{if not .ReadOnly -}}
	{{if .Description}}// {{ .Description }}
	{{end -}}
	{{.Name}} {{.Type}} `json:"{{.JSONName}},omitempty"`
	{{end -}}
{{end -}}
}

{{end}}
