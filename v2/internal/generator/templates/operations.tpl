// Code generated by scalr-gen. DO NOT EDIT.

package {{ .PackageName }}

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"iter"
	"net/http"
	"net/url"
	"strings"
	
	"github.com/scalr/go-scalr/v2/{{ .ApiPackageName }}/client"
	"github.com/scalr/go-scalr/v2/{{ .ApiPackageName }}/schemas"
)

// Client provides access to {{ .ResourceName }} operations
type Client struct {
	httpClient *client.HTTPClient
}

// New creates a new {{ .ResourceName }} client
func New(httpClient *client.HTTPClient) *Client {
	return &Client{httpClient: httpClient}
}

{{range .Operations -}}
{{if .Description}}// {{ .Description }}
{{end -}}
func (c *Client) {{ .Name }}Raw(ctx context.Context{{range .PathParameters}}, {{.GoName}} {{.Type}}{{end}}{{if .HasBody}}, req {{.RequestType}}{{end}}{{if .QueryParams}}, opts *{{ .Name }}Options{{end}}) (*http.Response, error) {
	path := "{{ .Path }}"
	{{range .PathParameters -}}
	path = strings.ReplaceAll(path, "{{`{`}}{{.Name}}{{`}`}}", url.PathEscape({{.GoName}}))
	{{end}}
	
	{{if .QueryParams -}}
	params := url.Values{}
	if opts != nil {
		{{range .QueryParams -}}
		{{if .IsFilter -}}
		{{else if .IsInclude -}}
		if len(opts.Include) > 0 {
			params.Set("include", strings.Join(opts.Include, ","))
		}
		{{else if .IsSort -}}
		if len(opts.Sort) > 0 {
			params.Set("sort", strings.Join(opts.Sort, ","))
		}
		{{else if .IsPagination -}}
		if opts.{{.GoName}} > 0 {
			params.Set("{{.Name}}", fmt.Sprintf("%d", opts.{{.GoName}}))
		}
		{{else -}}
		// Handle parameter: {{.GoName}} ({{.Type}})
		{{if eq .Type "string" -}}
		if opts.{{.GoName}} != "" {
			params.Set("{{.Name}}", opts.{{.GoName}})
		}
		{{else if eq .Type "bool" -}}
		params.Set("{{.Name}}", fmt.Sprintf("%t", opts.{{.GoName}}))
		{{else -}}
		// Complex type {{.Type}} - skip for now
		{{end -}}
		{{end -}}
		{{end -}}
		// Add filters
		for k, v := range opts.Filter {
			params.Set("filter["+k+"]", v)
		}
	}
	if len(params) > 0 {
		path += "?" + params.Encode()
	}
	{{end}}

	{{if .HasBody -}}
	{{if .UsesPlainJSON -}}
	// Plain JSON request (not JSON:API)
	headers := map[string]string{"Content-Type": "application/json"}
	return c.httpClient.{{if eq .Method "POST"}}Post{{else if eq .Method "PATCH"}}Patch{{else if eq .Method "PUT"}}Put{{else if eq .Method "DELETE"}}Delete{{else}}Post{{end}}(ctx, path, req, headers)
	{{else if .IsRelationshipOp -}}
	// This is a relationship operation - convert resources to relationship identifiers
	relationshipData := make([]map[string]interface{}, len(req))
	for i, item := range req {
		relationshipData[i] = map[string]interface{}{
			"id":   item.GetID(),
			"type": item.GetResourceType(),
		}
	}
	body := map[string]interface{}{"data": relationshipData}
	return c.httpClient.{{if eq .Method "POST"}}Post{{else if eq .Method "PATCH"}}Patch{{else if eq .Method "PUT"}}Put{{else if eq .Method "DELETE"}}Delete{{else}}Post{{end}}(ctx, path, body, nil)
	{{else -}}
	// Wrap request in JSON:API envelope
	body := map[string]interface{}{"data": req}
	return c.httpClient.{{if eq .Method "POST"}}Post{{else if eq .Method "PATCH"}}Patch{{else if eq .Method "PUT"}}Put{{else if eq .Method "DELETE"}}Delete{{else}}Post{{end}}(ctx, path, body, nil)
	{{end -}}
	{{else -}}
	{{if eq .Method "DELETE" -}}
	return c.httpClient.Delete(ctx, path, nil, nil)
	{{else -}}
	return c.httpClient.Get(ctx, path, nil)
	{{end -}}
	{{end -}}
}

{{if .Description}}// {{ .Description }}
{{end -}}
func (c *Client) {{ .Name }}(ctx context.Context{{range .PathParameters}}, {{.GoName}} {{.Type}}{{end}}{{if .HasBody}}, req {{.RequestType}}{{end}}{{if .QueryParams}}, opts *{{ .Name }}Options{{end}}) ({{if .ReturnsData}}{{.Returns}}, {{end}}*client.Response, error) {
	httpResp, err := c.{{ .Name }}Raw(ctx{{range .PathParameters}}, {{.GoName}}{{end}}{{if .HasBody}}, req{{end}}{{if .QueryParams}}, opts{{end}})
	if err != nil {
		return {{if .ReturnsData}}{{if .ReturnsText}}"", {{else}}nil, {{end}}{{end}}nil, err
	}
	defer httpResp.Body.Close()
	
	resp := &client.Response{Response: httpResp}
	
	{{if .ReturnsData -}}
	{{if .ReturnsText -}}
	bodyBytes, err := io.ReadAll(httpResp.Body)
	if err != nil {
		return "", resp, fmt.Errorf("failed to read response body: %w", err)
	}
	return string(bodyBytes), resp, nil
	{{else -}}

	{{if .IsList -}}
	var result struct {
		Data []{{trimPrefix .Returns "[]*"}} `json:"data"`
		Meta struct {
			Pagination *client.Pagination `json:"pagination"`
		} `json:"meta"`
		Included []map[string]interface{} `json:"included"`
	}
	{{else -}}
	var result struct {
		Data {{trimPrefix .Returns "*"}} `json:"data"`
		Included []map[string]interface{} `json:"included"`
	}
	{{end -}}
	
	if err := json.NewDecoder(httpResp.Body).Decode(&result); err != nil {
		return nil, resp, fmt.Errorf("failed to decode response: %w", err)
	}
	
	{{if .IsList -}}
	resources := make({{.Returns}}, len(result.Data))
	for i := range result.Data {
		resources[i] = &result.Data[i]
		{{if .ReturnsRelationships -}}
		// Populate included resources into relationships
		if len(result.Included) > 0 {
			resources[i].Relationships.PopulateIncludes(result.Included)
		}
		{{end -}}
	}
	resp.Pagination = result.Meta.Pagination
	return resources, resp, nil
	{{else -}}
	{{if .ReturnsRelationships -}}
	// Populate included resources into relationships
	if len(result.Included) > 0 {
		result.Data.Relationships.PopulateIncludes(result.Included)
	}
	{{end -}}
	return &result.Data, resp, nil
	{{end -}}
	{{end -}}
	{{else -}}
	return resp, nil
	{{end -}}
}

{{$hasPagination := false -}}
{{range .QueryParams -}}
{{if .IsPagination -}}
{{$hasPagination = true -}}
{{end -}}
{{end -}}
{{if and .IsList .ReturnsData .QueryParams $hasPagination (not (contains .Returns "interface{}")) -}}
// {{ .Name }}Iter returns an iterator for paginated results using Go 1.23+ range over iter.Seq2 feature.
// This is the recommended and simple way to iterate through all the results.
//
// The iterator automatically fetches pages as needed and handles errors inline.
//
// Example:
//
//	for item, err := range client.{{ $.ResourceName }}.{{ .Name }}Iter(ctx{{range .PathParameters}}, {{.GoName}}{{end}}, opts) {
//	    if err != nil {
//	        return err
//	    }
//	    // Process item
//	}
func (c *Client) {{ .Name }}Iter(ctx context.Context{{range .PathParameters}}, {{.GoName}} {{.Type}}{{end}}, opts *{{ .Name }}Options) iter.Seq2[{{trimPrefix .Returns "[]*"}}, error] {
	return func(yield func({{trimPrefix .Returns "[]*"}}, error) bool) {
		// Determine page size from opts or use default
		pageSize := 20
		if opts != nil && opts.PageSize > 0 {
			pageSize = opts.PageSize
		}

		pageNum := 1

		for {
			// Check context
			if err := ctx.Err(); err != nil {
				yield({{trimPrefix .Returns "[]*"}}{}, err)
				return
			}

			// Copy options and set page number
			pageOpts := &{{ .Name }}Options{}
			if opts != nil {
				*pageOpts = *opts
			}
			pageOpts.PageNumber = pageNum
			pageOpts.PageSize = pageSize

			// Fetch page
			items, resp, err := c.{{ .Name }}(ctx{{range .PathParameters}}, {{.GoName}}{{end}}, pageOpts)
			if err != nil {
				yield({{trimPrefix .Returns "[]*"}}{}, err)
				return
			}

			// Yield each item
			for _, item := range items {
				if !yield(*item, nil) {
					return // Consumer requested early exit
				}
			}

			// Check if there are more pages
			if resp.Pagination == nil || resp.Pagination.NextPage == nil {
				break
			}

			pageNum++
		}
	}
}

// {{ .Name }}Paged returns a stateful iterator with access to pagination metadata.
// Use this when you need PageInfo(), Remaining(), or Collect() methods.
//
// Example:
//
//	iter := client.{{ $.ResourceName }}.{{ .Name }}Paged(ctx{{range .PathParameters}}, {{.GoName}}{{end}}, opts)
//	for iter.Next() {
//	    item := iter.Value()
//	    fmt.Print(iter.PageInfo()) // -> "page 2/5"
//	    fmt.Printf("%d items remaining", iter.Remaining())
//	}
//	if err := iter.Err(); err != nil {
//	    // Handle error
//	}
func (c *Client) {{ .Name }}Paged(ctx context.Context{{range .PathParameters}}, {{.GoName}} {{.Type}}{{end}}, opts *{{ .Name }}Options) *client.Iterator[{{trimPrefix .Returns "[]*"}}] {
	// Determine page size from opts or use default
	pageSize := 20
	if opts != nil && opts.PageSize > 0 {
		pageSize = opts.PageSize
	}

	// Fetch function that will be called for each page
	fetchPage := func(ctx context.Context, pageNum int) ({{.Returns}}, *client.Pagination, error) {
		// Copy options and set page number
		pageOpts := &{{ .Name }}Options{}
		if opts != nil {
			*pageOpts = *opts
		}
		pageOpts.PageNumber = pageNum
		pageOpts.PageSize = pageSize

		// Call the actual list method
		items, resp, err := c.{{ .Name }}(ctx{{range .PathParameters}}, {{.GoName}}{{end}}, pageOpts)
		if err != nil {
			return nil, nil, err
		}

		return items, resp.Pagination, nil
	}

	return client.NewIterator[{{trimPrefix .Returns "[]*"}}](ctx, pageSize, fetchPage)
}
{{end -}}

{{if .QueryParams -}}
// {{ .Name }}Options holds optional parameters for {{ .Name }}
type {{ .Name }}Options struct {
	{{range .QueryParams -}}
	{{if not .IsFilter -}}
	{{if .Description}}// {{ .Description }}
	{{end -}}
	{{.GoName}} {{.Type}}
	{{end -}}
	{{end -}}
	Filter map[string]string
}
{{end}}

{{end -}}
